<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€åŒ–ç‰ˆäº‹ä»¶ç›‘å¬å™¨</title>
    
    <!-- åŠ è½½TronWebåº“ -->
    <script src="https://unpkg.com/tronweb@5.3.2/dist/TronWeb.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .status-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: #3b82f6;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: #2563eb;
        }

        .btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }

        .console-output {
            background: #000000;
            border: 1px solid #333333;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .console-header {
            position: sticky;
            top: 0;
            background: #1a1a1a;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .log-filters {
            display: flex;
            gap: 5px;
        }

        .filter-btn {
            padding: 2px 8px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .filter-btn:hover {
            background: #555;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 4px solid transparent;
            position: relative;
            transition: all 0.2s ease;
            word-wrap: break-word;
            background: rgba(255, 255, 255, 0.02);
        }

        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05) !important;
            transform: translateX(2px);
        }

        .log-timestamp {
            font-size: 10px;
            opacity: 0.6;
            margin-right: 8px;
            color: #888;
        }

        .log-category {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 8px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .log-info {
            color: #3b82f6;
            border-left-color: #3b82f6;
            background: rgba(59, 130, 246, 0.08);
        }

        .log-info .log-category {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .log-success {
            color: #10b981;
            border-left-color: #10b981;
            background: rgba(16, 185, 129, 0.08);
        }

        .log-success .log-category {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .log-warning {
            color: #f59e0b;
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.08);
        }

        .log-warning .log-category {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .log-error {
            color: #ef4444;
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.08);
            animation: errorPulse 0.5s ease-in-out;
        }

        .log-error .log-category {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .log-event {
            color: #8b5cf6;
            border-left-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.08);
            font-weight: bold;
            border: 1px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
        }

        .log-event .log-category {
            background: rgba(139, 92, 246, 0.2);
            color: #8b5cf6;
        }

        .log-debug {
            color: #90a4ae;
            border-left-color: #90a4ae;
            background: rgba(144, 164, 174, 0.05);
            font-size: 11px;
        }

        .log-debug .log-category {
            background: rgba(144, 164, 174, 0.2);
            color: #90a4ae;
        }

        @keyframes errorPulse {
            0% { background: rgba(239, 68, 68, 0.08); }
            50% { background: rgba(239, 68, 68, 0.2); }
            100% { background: rgba(239, 68, 68, 0.08); }
        }

        .event-group {
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(139, 92, 246, 0.05);
        }

        .event-header {
            font-weight: bold;
            color: #8b5cf6;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }

        .event-details {
            margin-left: 15px;
        }

        .hidden {
            display: none !important;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-label {
            display: block;
            color: #9ca3af;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .status-value {
            display: block;
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§ ç®€åŒ–ç‰ˆ TRON äº‹ä»¶ç›‘å¬å™¨</h1>
            <p>ç›‘å¬ CoordinatorFactory åˆçº¦äº‹ä»¶</p>
            <p style="font-size: 14px; color: #9ca3af;">åˆçº¦åœ°å€: TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc</p>
        </div>

        <div class="status-panel">
            <div class="status-grid">
                <div class="status-item">
                    <span class="status-label">è¿æ¥çŠ¶æ€</span>
                    <span class="status-value" id="connectionStatus">æœªè¿æ¥</span>
                </div>
                <div class="status-item">
                    <span class="status-label">äº‹ä»¶æ€»æ•°</span>
                    <span class="status-value" id="eventCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">é”™è¯¯æ¬¡æ•°</span>
                    <span class="status-value" id="errorCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">è¿è¡Œæ—¶é—´</span>
                    <span class="status-value" id="uptime">00:00:00</span>
                </div>
            </div>

            <div class="controls">
                <button class="btn" id="startBtn" onclick="startMonitoring()">ğŸš€ å¯åŠ¨ç›‘å¬</button>
                <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>ğŸ›‘ åœæ­¢ç›‘å¬</button>
                <button class="btn" onclick="clearConsole()">ğŸ§¹ æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn" onclick="testConnection()">ğŸ”— æµ‹è¯•è¿æ¥</button>
                <button class="btn" onclick="eventMonitor && eventMonitor.testEventHandling()">ğŸ§ª æµ‹è¯•äº‹ä»¶å¤„ç†</button>
                <button class="btn" onclick="eventMonitor && eventMonitor.checkRecentEvents()">ğŸ” æ£€æŸ¥æœ€è¿‘äº‹ä»¶</button>
                <button class="btn" onclick="checkLatestPresaleEvents()">ğŸ“Š æ£€æŸ¥æœ€æ–°é¢„å”®äº‹ä»¶</button>
            </div>
        </div>

        <div class="status-panel">
            <h3>ğŸ“ æ§åˆ¶å°è¾“å‡º</h3>
            <div class="console-output" id="consoleOutput">
                <div class="console-header">
                    <div class="log-filters">
                        <button class="filter-btn active" data-filter="all">å…¨éƒ¨</button>
                        <button class="filter-btn" data-filter="event">äº‹ä»¶</button>
                        <button class="filter-btn" data-filter="success">æˆåŠŸ</button>
                        <button class="filter-btn" data-filter="error">é”™è¯¯</button>
                        <button class="filter-btn" data-filter="warning">è­¦å‘Š</button>
                        <button class="filter-btn" data-filter="info">ä¿¡æ¯</button>
                    </div>
                    <div style="font-size: 11px; color: #888;">
                        <span id="logCount">0</span> æ¡æ—¥å¿—
                        <button onclick="clearConsole()" style="margin-left: 10px; padding: 2px 6px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer;">æ¸…ç©º</button>
                    </div>
                </div>
                <div id="logContainer">
                    <div class="log-entry log-info">
                        <span class="log-timestamp">[00:00:00]</span>
                        <span class="log-category">åˆå§‹åŒ–</span>
                        ç®€åŒ–ç‰ˆäº‹ä»¶ç›‘å¬å™¨å·²åŠ è½½
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventMonitor = null;
        let startTime = null;
        let uptimeTimer = null;
        let isMonitoring = false;
        let logCounter = 0;
        let logFilters = {
            all: true,
            event: true,
            success: true,
            error: true,
            warning: true,
            info: true,
            debug: true
        };

        // æ”¹è¿›çš„æ—¥å¿—å‡½æ•°
        function logToConsole(type, message, category = null) {
            try {
                logCounter++;
                const logContainer = document.getElementById('logContainer');
                const logCountElement = document.getElementById('logCount');

                if (!logContainer) {
                    console.error('æ—¥å¿—å®¹å™¨æœªæ‰¾åˆ°');
                    return;
                }

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.setAttribute('data-type', type);

                // æ·»åŠ æ—¶é—´æˆ³
                const timestamp = new Date().toLocaleTimeString();
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'log-timestamp';
                timestampSpan.textContent = `[${timestamp}]`;
                logEntry.appendChild(timestampSpan);

                // æ·»åŠ åˆ†ç±»æ ‡ç­¾
                if (category) {
                    const categorySpan = document.createElement('span');
                    categorySpan.className = 'log-category';
                    categorySpan.textContent = category;
                    logEntry.appendChild(categorySpan);
                }

                // æ·»åŠ æ¶ˆæ¯å†…å®¹
                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;
                logEntry.appendChild(messageSpan);

                // æ£€æŸ¥è¿‡æ»¤å™¨
                if (!logFilters[type] && !logFilters.all) {
                    logEntry.classList.add('hidden');
                }

                logContainer.appendChild(logEntry);

                // æ›´æ–°æ—¥å¿—è®¡æ•°
                if (logCountElement) {
                    logCountElement.textContent = logCounter;
                }

                // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                const consoleOutput = document.getElementById('consoleOutput');
                if (consoleOutput) {
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }

                // é™åˆ¶æ—¥å¿—æ•°é‡ï¼Œé¿å…å†…å­˜æº¢å‡º
                const maxLogs = 1000;
                const allLogs = logContainer.children;
                if (allLogs.length > maxLogs) {
                    for (let i = 0; i < allLogs.length - maxLogs; i++) {
                        logContainer.removeChild(allLogs[i]);
                    }
                }

            } catch (error) {
                console.error('æ—¥å¿—è®°å½•å¤±è´¥:', error);
            }
        }

        // æ—¥å¿—è¿‡æ»¤åŠŸèƒ½
        function initLogFilters() {
            try {
                const filterButtons = document.querySelectorAll('.filter-btn');
                filterButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        const filter = this.getAttribute('data-filter');

                        // æ›´æ–°æŒ‰é’®çŠ¶æ€
                        filterButtons.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');

                        // æ›´æ–°è¿‡æ»¤å™¨çŠ¶æ€
                        Object.keys(logFilters).forEach(key => {
                            logFilters[key] = (filter === 'all' || key === filter);
                        });

                        // åº”ç”¨è¿‡æ»¤å™¨
                        applyLogFilters();
                    });
                });
            } catch (error) {
                console.error('åˆå§‹åŒ–æ—¥å¿—è¿‡æ»¤å™¨å¤±è´¥:', error);
            }
        }

        function applyLogFilters() {
            try {
                const logEntries = document.querySelectorAll('.log-entry');
                logEntries.forEach(entry => {
                    const type = entry.getAttribute('data-type');
                    if (logFilters.all || logFilters[type]) {
                        entry.classList.remove('hidden');
                    } else {
                        entry.classList.add('hidden');
                    }
                });
            } catch (error) {
                console.error('åº”ç”¨æ—¥å¿—è¿‡æ»¤å™¨å¤±è´¥:', error);
            }
        }

        // æ¸…ç©ºæ§åˆ¶å°
        function clearConsole() {
            try {
                const logContainer = document.getElementById('logContainer');
                const logCountElement = document.getElementById('logCount');

                if (logContainer) {
                    logContainer.innerHTML = '';
                }

                if (logCountElement) {
                    logCountElement.textContent = '0';
                }

                logCounter = 0;
                logToConsole('info', 'æ§åˆ¶å°å·²æ¸…ç©º', 'ç³»ç»Ÿ');
            } catch (error) {
                console.error('æ¸…ç©ºæ§åˆ¶å°å¤±è´¥:', error);
            }
        }

        // ç®€åŒ–çš„äº‹ä»¶ç›‘å¬å™¨
        class SimpleEventMonitor {
            constructor() {
                this.tronWeb = null;
                this.isRunning = false;
                this.eventCount = 0;
                this.errorCount = 0;
                this.coordinatorAddress = 'TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc';
                this.contract = null;
                this.eventListeners = [];
                this.pollingInterval = null;
                this.lastBlockNumber = 0;
                
                // åŠ è½½å®Œæ•´çš„CoordinatorFactory ABI
                this.coordinatorABI = null; // å°†é€šè¿‡fetchåŠ è½½
            }

            async initialize() {
                try {
                    logToConsole('info', 'å¼€å§‹åˆå§‹åŒ–TronWeb...', 'åˆå§‹åŒ–');

                    // æ£€æŸ¥TronWebæ˜¯å¦å¯ç”¨
                    if (typeof window.TronWeb === 'undefined') {
                        throw new Error('TronWebåº“æœªåŠ è½½');
                    }

                    // åŠ è½½ABIæ–‡ä»¶
                    await this.loadABI();

                    // å°è¯•ä½¿ç”¨TronLink
                    if (window.tronWeb && window.tronWeb.ready) {
                        this.tronWeb = window.tronWeb;
                        logToConsole('success', 'ä½¿ç”¨TronLinkæä¾›çš„TronWeb', 'TronWeb');
                    } else {
                        // ä½¿ç”¨å…¬å…±èŠ‚ç‚¹ - ä¿®å¤æ„é€ å‡½æ•°è°ƒç”¨
                        this.tronWeb = new window.TronWeb(
                            'https://api.nileex.io',  // fullNode
                            'https://api.nileex.io',  // solidityNode
                            'https://api.nileex.io'   // eventServer
                        );
                        logToConsole('success', 'ä½¿ç”¨Nileæµ‹è¯•ç½‘èŠ‚ç‚¹è¿æ¥', 'TronWeb');
                    }

                    // æµ‹è¯•è¿æ¥
                    const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                    logToConsole('success', `å½“å‰åŒºå—: ${currentBlock.block_header.raw_data.number}`, 'è¿æ¥');

                    // æ£€æµ‹ TronWeb åŠŸèƒ½
                    this.detectTronWebCapabilities();

                    // è·³è¿‡åˆçº¦å®ä¾‹åˆ›å»ºï¼Œç›´æ¥ä½¿ç”¨TronWeb API
                    logToConsole('success', `TronWebåˆå§‹åŒ–æˆåŠŸï¼Œè·³è¿‡åˆçº¦å®ä¾‹åˆ›å»º`, 'åˆçº¦');
                    logToConsole('info', `ğŸ“ ç›‘å¬åˆçº¦åœ°å€: ${this.coordinatorAddress}`, 'åˆçº¦');
                    logToConsole('info', `ğŸ¯ ç›®æ ‡äº‹ä»¶: TokenPresalePairCreated`, 'åˆçº¦');

                    return true;

                } catch (error) {
                    logToConsole('error', `[åˆå§‹åŒ–] å¤±è´¥: ${error.message}`);
                    this.errorCount++;
                    throw error;
                }
            }

            detectTronWebCapabilities() {
                logToConsole('info', '[æ£€æµ‹] å¼€å§‹æ£€æµ‹ TronWeb åŠŸèƒ½...');

                // æ£€æµ‹ç‰ˆæœ¬
                if (this.tronWeb.version) {
                    logToConsole('info', `[æ£€æµ‹] TronWeb ç‰ˆæœ¬: ${this.tronWeb.version}`);
                } else {
                    logToConsole('info', `[æ£€æµ‹] TronWeb ç‰ˆæœ¬: æœªçŸ¥`);
                }

                // æ£€æµ‹äº‹ä»¶ç›¸å…³API
                const eventAPIs = [
                    'getEventResult',
                    'getEventByTransactionID',
                    'event'
                ];

                eventAPIs.forEach(api => {
                    const exists = !!this.tronWeb[api];
                    logToConsole('info', `[æ£€æµ‹] ${api}: ${exists ? 'âœ“ å¯ç”¨' : 'âœ— ä¸å¯ç”¨'}`);

                    if (api === 'event' && exists) {
                        try {
                            const eventMethods = Object.keys(this.tronWeb.event || {});
                            logToConsole('info', `[æ£€æµ‹] event å­æ–¹æ³•: ${eventMethods.join(', ')}`);
                        } catch (e) {
                            logToConsole('warning', `[æ£€æµ‹] æ— æ³•æ£€æµ‹ event å­æ–¹æ³•: ${e.message}`);
                        }
                    }
                });

                // æ£€æµ‹å…¶ä»–å¯èƒ½çš„äº‹ä»¶ç›¸å…³æ–¹æ³•
                const otherMethods = ['contract', 'trx'];
                otherMethods.forEach(method => {
                    const exists = !!this.tronWeb[method];
                    logToConsole('info', `[æ£€æµ‹] ${method}: ${exists ? 'âœ“ å¯ç”¨' : 'âœ— ä¸å¯ç”¨'}`);
                });

                // æ£€æµ‹ TronWeb çš„å…·ä½“ç±»å‹
                logToConsole('info', `[æ£€æµ‹] TronWeb æ„é€ å‡½æ•°: ${this.tronWeb.constructor.name}`);
                logToConsole('info', `[æ£€æµ‹] TronWeb åŸå‹é“¾: ${Object.getPrototypeOf(this.tronWeb).constructor.name}`);
            }

            async loadABI() {
                try {
                    logToConsole('info', '[ABI] åŠ è½½åˆçº¦ABI...');

                    // å°è¯•åŠ è½½å®Œæ•´çš„ABIæ–‡ä»¶
                    try {
                        const coordinatorResponse = await fetch('./src/tron/contracts/abis/CoordinatorFactoryABI.json');
                        const presaleResponse = await fetch('./src/tron/contracts/abis/presaleABI.json');
                        const tokenResponse = await fetch('./src/tron/contracts/abis/tokenABI.json');

                        if (coordinatorResponse.ok && presaleResponse.ok && tokenResponse.ok) {
                            this.coordinatorABI = await coordinatorResponse.json();
                            this.presaleABI = await presaleResponse.json();
                            this.tokenABI = await tokenResponse.json();
                            logToConsole('success', '[ABI] å®Œæ•´ABIæ–‡ä»¶åŠ è½½æˆåŠŸ');
                            return;
                        }
                    } catch (fetchError) {
                        logToConsole('warning', `[ABI] æ— æ³•åŠ è½½å®Œæ•´ABIæ–‡ä»¶: ${fetchError.message}`);
                    }

                    // ä½¿ç”¨åŸºç¡€çš„äº‹ä»¶ABIä½œä¸ºå¤‡ç”¨
                    this.coordinatorABI = [
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "presale", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "creator", "type": "address"},
                                {"indexed": false, "internalType": "uint256", "name": "totalSupply", "type": "uint256"}
                            ],
                            "name": "TokenPresalePairCreated",
                            "type": "event"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "previousOwner", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "newOwner", "type": "address"}
                            ],
                            "name": "OwnershipTransferred",
                            "type": "event"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "presale", "type": "address"}
                            ],
                            "name": "TokenPresaleLinked",
                            "type": "event"
                        }
                    ];

                    // åŸºç¡€çš„é¢„å”®ABI
                    this.presaleABI = [
                        {"inputs": [], "name": "hardcap", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "maxBuyPerWallet", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "startTime", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "getLGEConfig", "outputs": [
                            {"internalType": "uint256", "name": "vestingDelay_", "type": "uint256"},
                            {"internalType": "uint256", "name": "vestingRate_", "type": "uint256"},
                            {"internalType": "bool", "name": "vestingEnabled_", "type": "bool"},
                            {"internalType": "uint256", "name": "backingShare_", "type": "uint256"},
                            {"internalType": "address", "name": "backingReceiver_", "type": "address"},
                            {"internalType": "uint256", "name": "startTime_", "type": "uint256"},
                            {"internalType": "uint256", "name": "hardcap_", "type": "uint256"},
                            {"internalType": "uint256", "name": "maxBuyPerWallet_", "type": "uint256"}
                        ], "stateMutability": "view", "type": "function"}
                    ];

                    // åŸºç¡€çš„ä»£å¸ABI
                    this.tokenABI = [
                        {"inputs": [], "name": "name", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "totalSupply", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "pairTRX", "outputs": [{"internalType": "address", "name": "", "type": "address"}], "stateMutability": "view", "type": "function"}
                    ];

                    logToConsole('success', '[ABI] åŸºç¡€ABIåŠ è½½æˆåŠŸ');

                } catch (error) {
                    logToConsole('error', `[ABI] ABIåŠ è½½å¤±è´¥: ${error.message}`);
                    throw error;
                }
            }

            async start() {
                if (this.isRunning) {
                    logToConsole('warning', '[å¯åŠ¨] ç›‘å¬å™¨å·²åœ¨è¿è¡Œ');
                    return;
                }

                try {
                    this.isRunning = true;
                    logToConsole('info', '[å¯åŠ¨] å¼€å§‹ç›‘å¬äº‹ä»¶...');

                    // å°è¯•äº‹ä»¶ç›‘å¬
                    let eventListenersSet = 0;

                    // ç›‘å¬TokenPresalePairCreatedäº‹ä»¶
                    if (await this.listenToEvent('TokenPresalePairCreated')) {
                        eventListenersSet++;
                    }

                    // ç›‘å¬OwnershipTransferredäº‹ä»¶
                    if (await this.listenToEvent('OwnershipTransferred')) {
                        eventListenersSet++;
                    }

                    // ç›‘å¬TokenPresaleLinkedäº‹ä»¶
                    if (await this.listenToEvent('TokenPresaleLinked')) {
                        eventListenersSet++;
                    }

                    // ç›‘å¬LGEConfigSetäº‹ä»¶
                    if (await this.listenToEvent('LGEConfigSet')) {
                        eventListenersSet++;
                    }

                    // ç›‘å¬VestingConfigSetäº‹ä»¶
                    if (await this.listenToEvent('VestingConfigSet')) {
                        eventListenersSet++;
                    }

                    // ç›‘å¬BackingConfigSetäº‹ä»¶
                    if (await this.listenToEvent('BackingConfigSet')) {
                        eventListenersSet++;
                    }

                    if (eventListenersSet === 0) {
                        logToConsole('warning', '[å¯åŠ¨] äº‹ä»¶ç›‘å¬è®¾ç½®å¤±è´¥ï¼Œå¯ç”¨è½®è¯¢æ¨¡å¼');
                        this.startPolling();
                    } else {
                        logToConsole('success', `[å¯åŠ¨] äº‹ä»¶ç›‘å¬å·²å¯åŠ¨ (${eventListenersSet}/6 ä¸ªç›‘å¬å™¨)`);
                    }

                } catch (error) {
                    logToConsole('error', `[å¯åŠ¨] å¤±è´¥: ${error.message}`);
                    this.errorCount++;
                    this.isRunning = false;
                    throw error;
                }
            }

            async listenToEvent(eventName) {
                try {
                    logToConsole('info', `[äº‹ä»¶] å°è¯•è®¾ç½® ${eventName} ç›‘å¬...`);

                    // æ–¹æ³•1: ä½¿ç”¨ TronWeb.trx.getEventResult è½®è¯¢æ–¹å¼
                    try {
                        if (this.tronWeb.trx && this.tronWeb.trx.getEventResult) {
                            logToConsole('info', `[äº‹ä»¶] ä½¿ç”¨ TronWeb.trx.getEventResult æ–¹æ³•ç›‘å¬ ${eventName}`);

                            // è®°å½•ä¸Šæ¬¡æ£€æŸ¥çš„æ—¶é—´æˆ³ï¼Œé¿å…é‡å¤å¤„ç†
                            let lastCheckTime = Date.now();

                            // å¯åŠ¨è½®è¯¢ç›‘å¬
                            const pollInterval = setInterval(async () => {
                                try {
                                    const events = await this.tronWeb.trx.getEventResult(this.coordinatorAddress, {
                                        eventName: eventName,
                                        size: 20,
                                        onlyConfirmed: false,
                                        sinceTimestamp: lastCheckTime
                                    });

                                    if (events && events.length > 0) {
                                        logToConsole('info', `[äº‹ä»¶] è·å–åˆ° ${events.length} ä¸ª ${eventName} äº‹ä»¶`);

                                        // è¿‡æ»¤å‡ºæ–°äº‹ä»¶ï¼ˆé¿å…é‡å¤å¤„ç†ï¼‰
                                        const newEvents = events.filter(event => {
                                            const eventTime = event.timestamp || event.block_timestamp || Date.now();
                                            return eventTime > lastCheckTime;
                                        });

                                        if (newEvents.length > 0) {
                                            logToConsole('success', `[äº‹ä»¶] å‘ç° ${newEvents.length} ä¸ªæ–°çš„ ${eventName} äº‹ä»¶`);
                                            newEvents.forEach(event => {
                                                this.handleEvent(eventName, event);
                                            });
                                        } else {
                                            logToConsole('info', `[äº‹ä»¶] æ²¡æœ‰æ–°çš„ ${eventName} äº‹ä»¶`);
                                        }

                                        lastCheckTime = Date.now();
                                    } else {
                                        logToConsole('info', `[äº‹ä»¶] æœªè·å–åˆ° ${eventName} äº‹ä»¶`);
                                    }
                                } catch (pollError) {
                                    logToConsole('warning', `[äº‹ä»¶] è½®è¯¢ ${eventName} é”™è¯¯: ${pollError.message}`);
                                }
                            }, 3000); // æ¯3ç§’è½®è¯¢ä¸€æ¬¡

                            this.eventListeners.push({ interval: pollInterval, eventName });
                            logToConsole('success', `[äº‹ä»¶] ä½¿ç”¨ trx.getEventResult è½®è¯¢æ–¹å¼ç›‘å¬ ${eventName}`);
                            return true;
                        }
                    } catch (pollError) {
                        logToConsole('warning', `[äº‹ä»¶] trx.getEventResultæ–¹æ³•å¤±è´¥: ${pollError.message}`);
                    }

                    // æ–¹æ³•1.1: å°è¯•ç›´æ¥ä½¿ç”¨ TronWeb.getEventResult
                    try {
                        if (this.tronWeb.getEventResult) {
                            logToConsole('info', `[äº‹ä»¶] ä½¿ç”¨ TronWeb.getEventResult æ–¹æ³•ç›‘å¬ ${eventName}`);

                            let lastCheckTime = Date.now();

                            const pollInterval = setInterval(async () => {
                                try {
                                    const events = await this.tronWeb.getEventResult(this.coordinatorAddress, {
                                        eventName: eventName,
                                        size: 20,
                                        onlyConfirmed: false
                                    });

                                    if (events && events.length > 0) {
                                        logToConsole('info', `[äº‹ä»¶] è·å–åˆ° ${events.length} ä¸ª ${eventName} äº‹ä»¶`);
                                        events.forEach(event => {
                                            this.handleEvent(eventName, event);
                                        });
                                    }
                                } catch (pollError) {
                                    logToConsole('warning', `[äº‹ä»¶] è½®è¯¢ ${eventName} é”™è¯¯: ${pollError.message}`);
                                }
                            }, 3000);

                            this.eventListeners.push({ interval: pollInterval, eventName });
                            logToConsole('success', `[äº‹ä»¶] ä½¿ç”¨ getEventResult è½®è¯¢æ–¹å¼ç›‘å¬ ${eventName}`);
                            return true;
                        }
                    } catch (pollError) {
                        logToConsole('warning', `[äº‹ä»¶] getEventResultæ–¹æ³•å¤±è´¥: ${pollError.message}`);
                    }

                    // æ–¹æ³•2: ä½¿ç”¨ TronWeb.getEventByTransactionID (éœ€è¦äº¤æ˜“ID)
                    try {
                        if (this.tronWeb.getEventByTransactionID) {
                            logToConsole('info', `[äº‹ä»¶] TronWeb.getEventByTransactionID æ–¹æ³•å¯ç”¨`);
                            // è¿™ä¸ªæ–¹æ³•éœ€è¦å…·ä½“çš„äº¤æ˜“IDï¼Œæš‚æ—¶è·³è¿‡
                        }
                    } catch (error) {
                        logToConsole('warning', `[äº‹ä»¶] getEventByTransactionIDæ–¹æ³•æµ‹è¯•å¤±è´¥: ${error.message}`);
                    }

                    // æ–¹æ³•3: ä½¿ç”¨ contract.getPastEvents (å¦‚æœæ”¯æŒ)
                    try {
                        if (this.contract.getPastEvents) {
                            logToConsole('info', `[äº‹ä»¶] å°è¯•ä½¿ç”¨ getPastEvents æ–¹æ³•`);

                            const pastEvents = await this.contract.getPastEvents(eventName, {
                                fromBlock: 'latest',
                                toBlock: 'latest'
                            });

                            logToConsole('success', `[äº‹ä»¶] getPastEvents æ–¹æ³•å¯ç”¨ï¼Œè·å–åˆ° ${pastEvents.length} ä¸ªå†å²äº‹ä»¶`);

                            // å¯åŠ¨å®šæœŸæ£€æŸ¥
                            const checkInterval = setInterval(async () => {
                                try {
                                    const newEvents = await this.contract.getPastEvents(eventName, {
                                        fromBlock: 'latest',
                                        toBlock: 'latest'
                                    });

                                    newEvents.forEach(event => {
                                        this.handleEvent(eventName, event);
                                    });
                                } catch (checkError) {
                                    logToConsole('warning', `[äº‹ä»¶] æ£€æŸ¥ ${eventName} æ–°äº‹ä»¶é”™è¯¯: ${checkError.message}`);
                                }
                            }, 3000);

                            this.eventListeners.push({ interval: checkInterval, eventName });
                            logToConsole('success', `[äº‹ä»¶] ä½¿ç”¨ getPastEvents ç›‘å¬ ${eventName}`);
                            return true;
                        }
                    } catch (pastEventsError) {
                        logToConsole('warning', `[äº‹ä»¶] getPastEventsæ–¹æ³•å¤±è´¥: ${pastEventsError.message}`);
                    }

                    // æ–¹æ³•4: ä½¿ç”¨åŒºå—è½®è¯¢æ£€æµ‹äº‹ä»¶
                    try {
                        logToConsole('info', `[äº‹ä»¶] ä½¿ç”¨åŒºå—è½®è¯¢æ–¹å¼ç›‘å¬ ${eventName}`);

                        let lastBlockNumber = 0;

                        // è·å–å½“å‰åŒºå—å·
                        try {
                            const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                            lastBlockNumber = currentBlock.block_header.raw_data.number;
                            logToConsole('info', `[äº‹ä»¶] å¼€å§‹ä»åŒºå— ${lastBlockNumber} ç›‘å¬`);
                        } catch (blockError) {
                            logToConsole('warning', `[äº‹ä»¶] è·å–å½“å‰åŒºå—å¤±è´¥: ${blockError.message}`);
                        }

                        const blockPollInterval = setInterval(async () => {
                            try {
                                const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                                const currentBlockNumber = currentBlock.block_header.raw_data.number;

                                if (currentBlockNumber > lastBlockNumber) {
                                    // æ£€æŸ¥æ–°åŒºå—ä¸­çš„äº‹ä»¶
                                    for (let blockNum = lastBlockNumber + 1; blockNum <= currentBlockNumber; blockNum++) {
                                        try {
                                            const block = await this.tronWeb.trx.getBlock(blockNum);
                                            if (block && block.transactions) {
                                                // æ£€æŸ¥åŒºå—ä¸­çš„äº¤æ˜“æ˜¯å¦ä¸æˆ‘ä»¬çš„åˆçº¦ç›¸å…³
                                                block.transactions.forEach(async (tx) => {
                                                    if (tx.raw_data && tx.raw_data.contract) {
                                                        tx.raw_data.contract.forEach(async (contract) => {
                                                            if (contract.parameter && contract.parameter.value) {
                                                                const contractAddress = this.tronWeb.address.fromHex(contract.parameter.value.contract_address);
                                                                if (contractAddress === this.coordinatorAddress) {
                                                                    // è¿™æ˜¯æˆ‘ä»¬å…³å¿ƒçš„åˆçº¦äº¤æ˜“ï¼Œå°è¯•è·å–äº‹ä»¶
                                                                    try {
                                                                        const txEvents = await this.tronWeb.getEventByTransactionID(tx.txID);
                                                                        if (txEvents && txEvents.length > 0) {
                                                                            txEvents.forEach(event => {
                                                                                if (event.event === eventName) {
                                                                                    this.handleEvent(eventName, event);
                                                                                }
                                                                            });
                                                                        }
                                                                    } catch (eventError) {
                                                                        // å¿½ç•¥å•ä¸ªäº¤æ˜“çš„äº‹ä»¶è·å–é”™è¯¯
                                                                    }
                                                                }
                                                            }
                                                        });
                                                    }
                                                });
                                            }
                                        } catch (blockError) {
                                            // å¿½ç•¥å•ä¸ªåŒºå—çš„é”™è¯¯
                                        }
                                    }
                                    lastBlockNumber = currentBlockNumber;
                                }
                            } catch (pollError) {
                                logToConsole('warning', `[äº‹ä»¶] åŒºå—è½®è¯¢é”™è¯¯: ${pollError.message}`);
                            }
                        }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡æ–°åŒºå—

                        this.eventListeners.push({ interval: blockPollInterval, eventName, type: 'block' });
                        logToConsole('success', `[äº‹ä»¶] ä½¿ç”¨åŒºå—è½®è¯¢æ–¹å¼ç›‘å¬ ${eventName}`);
                        return true;

                    } catch (blockError) {
                        logToConsole('warning', `[äº‹ä»¶] åŒºå—è½®è¯¢æ–¹å¼å¤±è´¥: ${blockError.message}`);
                    }

                    // æ–¹æ³•5: ä½¿ç”¨åŸç”Ÿ TronWeb äº‹ä»¶ç›‘å¬ (å¦‚æœæ”¯æŒ)
                    try {
                        // æ£€æŸ¥ TronWeb æ˜¯å¦æœ‰äº‹ä»¶ç›¸å…³çš„API
                        logToConsole('info', `[äº‹ä»¶] æ£€æŸ¥ TronWeb äº‹ä»¶API...`);
                        logToConsole('info', `[äº‹ä»¶] TronWeb.event å­˜åœ¨: ${!!this.tronWeb.event}`);
                        logToConsole('info', `[äº‹ä»¶] TronWeb.getEventResult å­˜åœ¨: ${!!this.tronWeb.getEventResult}`);
                        logToConsole('info', `[äº‹ä»¶] TronWeb.getEventByTransactionID å­˜åœ¨: ${!!this.tronWeb.getEventByTransactionID}`);

                        // å°è¯•ä½¿ç”¨ TronWeb çš„äº‹ä»¶ç›‘å¬
                        if (this.tronWeb.event && this.tronWeb.event.watch) {
                            const watcher = this.tronWeb.event.watch(this.coordinatorAddress, {
                                eventName: eventName,
                                onlyConfirmed: false
                            }, (error, result) => {
                                if (error) {
                                    logToConsole('error', `[äº‹ä»¶] ${eventName} ç›‘å¬é”™è¯¯: ${error.message}`);
                                    this.errorCount++;
                                } else if (result) {
                                    this.handleEvent(eventName, result);
                                }
                            });

                            this.eventListeners.push(watcher);
                            logToConsole('success', `[äº‹ä»¶] ä½¿ç”¨ TronWeb.event.watch ç›‘å¬ ${eventName}`);
                            return true;
                        }
                    } catch (nativeError) {
                        logToConsole('warning', `[äº‹ä»¶] åŸç”Ÿäº‹ä»¶ç›‘å¬å¤±è´¥: ${nativeError.message}`);
                    }

                    // å¦‚æœæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥äº†
                    logToConsole('error', `[äº‹ä»¶] æ— æ³•è®¾ç½® ${eventName} ç›‘å¬ï¼Œæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥äº†`);
                    return false;

                } catch (error) {
                    logToConsole('error', `[äº‹ä»¶] è®¾ç½® ${eventName} ç›‘å¬å¤±è´¥: ${error.message}`);
                    this.errorCount++;
                    return false;
                }
            }

            startPolling() {
                logToConsole('info', '[è½®è¯¢] å¯åŠ¨åŒºå—è½®è¯¢æ¨¡å¼...');

                this.pollingInterval = setInterval(async () => {
                    try {
                        const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                        const currentBlockNumber = currentBlock.block_header.raw_data.number;

                        if (this.lastBlockNumber === 0) {
                            this.lastBlockNumber = currentBlockNumber;
                            logToConsole('info', `[è½®è¯¢] å¼€å§‹ä»åŒºå— ${currentBlockNumber} ç›‘å¬`);
                            return;
                        }

                        if (currentBlockNumber > this.lastBlockNumber) {
                            logToConsole('info', `[è½®è¯¢] æ£€æŸ¥æ–°åŒºå— ${this.lastBlockNumber + 1} åˆ° ${currentBlockNumber}`);

                            // æ£€æŸ¥æ–°åŒºå—ä¸­çš„äº‹ä»¶
                            for (let blockNum = this.lastBlockNumber + 1; blockNum <= currentBlockNumber; blockNum++) {
                                await this.checkBlockForEvents(blockNum);
                            }

                            this.lastBlockNumber = currentBlockNumber;
                        }

                    } catch (error) {
                        logToConsole('error', `[è½®è¯¢] è½®è¯¢é”™è¯¯: ${error.message}`);
                        this.errorCount++;
                    }
                }, 3000); // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡
            }

            async checkBlockForEvents(blockNumber) {
                try {
                    // è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„åŒºå—äº‹ä»¶æ£€æŸ¥é€»è¾‘
                    // ç”±äºTronWebçš„é™åˆ¶ï¼Œæˆ‘ä»¬ä¸»è¦ç”¨äºæ¼”ç¤ºè½®è¯¢æœºåˆ¶
                    logToConsole('info', `[è½®è¯¢] æ£€æŸ¥åŒºå— ${blockNumber} ä¸­çš„äº‹ä»¶...`);

                } catch (error) {
                    logToConsole('error', `[è½®è¯¢] æ£€æŸ¥åŒºå— ${blockNumber} å¤±è´¥: ${error.message}`);
                }
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                    logToConsole('info', '[è½®è¯¢] åŒºå—è½®è¯¢å·²åœæ­¢');
                }
            }

            async handleEvent(eventName, eventData) {
                try {
                    this.eventCount++;

                    const timestamp = new Date().toLocaleTimeString();
                    const contractAddr = this.coordinatorAddress.slice(0, 8) + '...';

                    // åˆ›å»ºäº‹ä»¶åˆ†ç»„
                    this.createEventGroup(eventName, timestamp, contractAddr);

                    logToConsole('event', `ğŸ¯ ${eventName} äº‹ä»¶è§¦å‘`, 'äº‹ä»¶');

                    // è¯¦ç»†è°ƒè¯•ï¼šæ˜¾ç¤ºå®Œæ•´çš„äº‹ä»¶æ•°æ®ç»“æ„
                    logToConsole('debug', `äº‹ä»¶æ•°æ®ç»“æ„: ${JSON.stringify(eventData, null, 2)}`, 'è°ƒè¯•');

                    // å°è¯•å¤šç§å¯èƒ½çš„äº‹ä»¶æ•°æ®æ ¼å¼
                    let eventParams = null;
                    let blockNumber = null;
                    let transactionId = null;

                    // æ ¼å¼1: eventData.result
                    if (eventData.result) {
                        eventParams = eventData.result;
                        blockNumber = eventData.block;
                        transactionId = eventData.transaction;
                    }
                    // æ ¼å¼2: eventDataç›´æ¥åŒ…å«å‚æ•°
                    else if (eventData.returnValues || eventData.args) {
                        eventParams = eventData.returnValues || eventData.args;
                        blockNumber = eventData.blockNumber;
                        transactionId = eventData.transactionHash;
                    }
                    // æ ¼å¼3: TronWebç‰¹å®šæ ¼å¼
                    else if (eventData.event) {
                        eventParams = eventData.result || eventData.parameters;
                        blockNumber = eventData.block_number;
                        transactionId = eventData.transaction_id;
                    }
                    // æ ¼å¼4: ç›´æ¥å‚æ•°
                    else {
                        eventParams = eventData;
                    }

                    logToConsole('info', `[è§£æ] äº‹ä»¶å‚æ•°: ${JSON.stringify(eventParams, null, 2)}`);
                    logToConsole('info', `[è§£æ] åŒºå—å·: ${blockNumber}, äº¤æ˜“ID: ${transactionId}`);

                    // æ ¹æ®äº‹ä»¶ç±»å‹è¿›è¡Œä¸“é—¨å¤„ç†
                    switch (eventName) {
                        case 'TokenPresalePairCreated':
                            await this.handleTokenPresalePairCreated(eventParams, blockNumber, transactionId);
                            break;
                        case 'OwnershipTransferred':
                            await this.handleOwnershipTransferred(eventParams, blockNumber, transactionId);
                            break;
                        case 'TokenPresaleLinked':
                            await this.handleTokenPresaleLinked(eventParams, blockNumber, transactionId);
                            break;
                        case 'LGEConfigSet':
                            await this.handleLGEConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        case 'VestingConfigSet':
                            await this.handleVestingConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        case 'BackingConfigSet':
                            await this.handleBackingConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        default:
                            await this.handleGenericEvent(eventName, eventParams, blockNumber, transactionId);
                    }

                    // æ›´æ–°UI
                    document.getElementById('eventCount').textContent = this.eventCount;

                } catch (error) {
                    logToConsole('error', `[å¤„ç†] å¤„ç†äº‹ä»¶å¤±è´¥: ${error.message}`);
                    logToConsole('error', `[å¤„ç†] é”™è¯¯å †æ ˆ: ${error.stack}`);
                    this.errorCount++;
                }
            }

            createEventGroup(eventName, timestamp, contractAddr) {
                try {
                    const logContainer = document.getElementById('logContainer');
                    if (!logContainer) return;

                    const eventGroup = document.createElement('div');
                    eventGroup.className = 'event-group';
                    eventGroup.setAttribute('data-type', 'event');

                    const eventHeader = document.createElement('div');
                    eventHeader.className = 'event-header';
                    eventHeader.innerHTML = `
                        <span style="font-size: 14px;">ğŸ¯ ${eventName}</span>
                        <span style="float: right; font-size: 12px; opacity: 0.7;">${timestamp} | ${contractAddr}</span>
                    `;

                    const eventDetails = document.createElement('div');
                    eventDetails.className = 'event-details';
                    eventDetails.id = `event-details-${this.eventCount}`;

                    eventGroup.appendChild(eventHeader);
                    eventGroup.appendChild(eventDetails);
                    logContainer.appendChild(eventGroup);

                    // è‡ªåŠ¨æ»šåŠ¨
                    const consoleOutput = document.getElementById('consoleOutput');
                    if (consoleOutput) {
                        consoleOutput.scrollTop = consoleOutput.scrollHeight;
                    }

                } catch (error) {
                    console.error('åˆ›å»ºäº‹ä»¶åˆ†ç»„å¤±è´¥:', error);
                }
            }

            logEventDetail(message, type = 'info') {
                try {
                    const eventDetailsContainer = document.getElementById(`event-details-${this.eventCount}`);
                    if (!eventDetailsContainer) {
                        logToConsole(type, message, 'äº‹ä»¶è¯¦æƒ…');
                        return;
                    }

                    const detailEntry = document.createElement('div');
                    detailEntry.className = `log-entry log-${type}`;
                    detailEntry.style.margin = '2px 0';
                    detailEntry.style.padding = '4px 8px';
                    detailEntry.style.fontSize = '12px';

                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    detailEntry.appendChild(messageSpan);

                    eventDetailsContainer.appendChild(detailEntry);

                } catch (error) {
                    console.error('è®°å½•äº‹ä»¶è¯¦æƒ…å¤±è´¥:', error);
                    logToConsole(type, message, 'äº‹ä»¶è¯¦æƒ…');
                }
            }

            async handleTokenPresalePairCreated(eventParams, blockNumber, transactionId) {
                try {
                    this.logEventDetail('ğŸš€ æ£€æµ‹åˆ°æ–°çš„ä»£å¸é¢„å”®é…å¯¹åˆ›å»ºäº‹ä»¶ï¼', 'success');

                    // è§£æäº‹ä»¶å‚æ•°
                    let tokenAddress = null;
                    let presaleAddress = null;

                    if (eventParams) {
                        // å°è¯•å¤šç§å‚æ•°æ ¼å¼
                        tokenAddress = eventParams.token || eventParams.tokenAddress || eventParams[0];
                        presaleAddress = eventParams.presale || eventParams.presaleAddress || eventParams[1];

                        if (tokenAddress && typeof tokenAddress === 'object' && tokenAddress._hex) {
                            tokenAddress = this.tronWeb.address.fromHex(tokenAddress._hex);
                        }
                        if (presaleAddress && typeof presaleAddress === 'object' && presaleAddress._hex) {
                            presaleAddress = this.tronWeb.address.fromHex(presaleAddress._hex);
                        }
                    }

                    this.logEventDetail(`ğŸ“ ä»£å¸åœ°å€: ${tokenAddress}`, 'info');
                    this.logEventDetail(`ğŸ“ é¢„å”®åœ°å€: ${presaleAddress}`, 'info');
                    this.logEventDetail(`ğŸ“¦ åŒºå—å·: ${blockNumber}`, 'info');
                    this.logEventDetail(`ğŸ”— äº¤æ˜“ID: ${transactionId}`, 'info');

                    // è·å–ä»£å¸è¯¦ç»†ä¿¡æ¯
                    if (tokenAddress) {
                        this.logEventDetail('æ­£åœ¨è·å–ä»£å¸è¯¦ç»†ä¿¡æ¯...', 'info');
                        await this.getTokenDetails(tokenAddress);
                    }

                    // è·å–é¢„å”®è¯¦ç»†ä¿¡æ¯
                    if (presaleAddress) {
                        this.logEventDetail('æ­£åœ¨è·å–é¢„å”®è¯¦ç»†ä¿¡æ¯...', 'info');
                        await this.getPresaleDetails(presaleAddress);
                    }

                    // å±•ç¤ºå®Œæ•´çš„é¢„å”®é…ç½®ä¿¡æ¯
                    this.logEventDetail('=== é¢„å”®é…ç½®ä¿¡æ¯æ±‡æ€» ===', 'success');
                    await this.displayPresaleConfigSummary(tokenAddress, presaleAddress);

                } catch (error) {
                    this.logEventDetail(`å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                    logToConsole('error', `TokenPresalePairCreated å¤„ç†å¤±è´¥: ${error.message}`, 'é”™è¯¯');
                }
            }

            async handleOwnershipTransferred(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('info', 'ğŸ‘‘ æ£€æµ‹åˆ°æ‰€æœ‰æƒè½¬ç§»äº‹ä»¶');

                    let previousOwner = null;
                    let newOwner = null;

                    if (eventParams) {
                        previousOwner = eventParams.previousOwner || eventParams[0];
                        newOwner = eventParams.newOwner || eventParams[1];

                        if (previousOwner && typeof previousOwner === 'object' && previousOwner._hex) {
                            previousOwner = this.tronWeb.address.fromHex(previousOwner._hex);
                        }
                        if (newOwner && typeof newOwner === 'object' && newOwner._hex) {
                            newOwner = this.tronWeb.address.fromHex(newOwner._hex);
                        }
                    }

                    logToConsole('info', `ğŸ“ åŸæ‰€æœ‰è€…: ${previousOwner}`);
                    logToConsole('info', `ğŸ“ æ–°æ‰€æœ‰è€…: ${newOwner}`);
                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[OwnershipTransferred] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            async handleTokenPresaleLinked(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', 'ğŸ”— æ£€æµ‹åˆ°ä»£å¸é¢„å”®é“¾æ¥äº‹ä»¶ï¼');

                    let tokenAddress = null;
                    let presaleAddress = null;

                    if (eventParams) {
                        tokenAddress = eventParams.token || eventParams.tokenAddress || eventParams[0];
                        presaleAddress = eventParams.presale || eventParams.presaleAddress || eventParams[1];

                        if (tokenAddress && typeof tokenAddress === 'object' && tokenAddress._hex) {
                            tokenAddress = this.tronWeb.address.fromHex(tokenAddress._hex);
                        }
                        if (presaleAddress && typeof presaleAddress === 'object' && presaleAddress._hex) {
                            presaleAddress = this.tronWeb.address.fromHex(presaleAddress._hex);
                        }
                    }

                    logToConsole('info', `ğŸ“ ä»£å¸åœ°å€: ${tokenAddress}`);
                    logToConsole('info', `ğŸ“ é¢„å”®åœ°å€: ${presaleAddress}`);
                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                    // è·å–ä»£å¸è¯¦ç»†ä¿¡æ¯
                    if (tokenAddress) {
                        await this.getTokenDetails(tokenAddress);
                    }

                    // è·å–é¢„å”®è¯¦ç»†ä¿¡æ¯
                    if (presaleAddress) {
                        await this.getPresaleDetails(presaleAddress);
                    }

                } catch (error) {
                    logToConsole('error', `[TokenPresaleLinked] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            async handleGenericEvent(eventName, eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('info', `ğŸ“‹ é€šç”¨äº‹ä»¶å¤„ç†: ${eventName}`);

                    if (eventParams) {
                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // è·³è¿‡æ•°å­—ç´¢å¼•

                            let displayValue = value;
                            if (typeof value === 'string' && value.length > 42) {
                                displayValue = value.slice(0, 8) + '...' + value.slice(-4);
                            }

                            logToConsole('info', `  â–¸ ${key}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[GenericEvent] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            async getTokenDetails(tokenAddress) {
                try {
                    this.logEventDetail('=== ç¬¬äºŒç»„ - ä»£å¸åŸºç¡€ä¿¡æ¯ ===', 'success');
                    this.logEventDetail(`ğŸª™ è·å–ä»£å¸è¯¦ç»†ä¿¡æ¯: ${tokenAddress}`, 'info');

                    // ä½¿ç”¨åŠ è½½çš„å®Œæ•´tokenABIæˆ–åŸºç¡€ABI
                    const tokenABI = this.tokenABI || [
                        {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"pairTRX","outputs":[{"name":"","type":"address"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"baseConfig","outputs":[
                            {"name":"feeBuy","type":"uint256"},
                            {"name":"feeSell","type":"uint256"},
                            {"name":"lpBurnEnabled","type":"bool"},
                            {"name":"lpBurnFrequency","type":"uint256"},
                            {"name":"percentForLPBurn","type":"uint256"},
                            {"name":"burnLimit","type":"uint256"},
                            {"name":"protectTime","type":"uint256"},
                            {"name":"protectFee","type":"uint256"},
                            {"name":"isInsideSell","type":"bool"},
                            {"name":"swapThreshold","type":"uint256"}
                        ],"type":"function"}
                    ];

                    const tokenContract = await this.tronWeb.contract(tokenABI, tokenAddress);

                    // è·å–ä»£å¸åç§°
                    try {
                        const name = await tokenContract.name().call();
                        this.logEventDetail(`ğŸ“› Token nameï¼ˆä»£å¸åç§°ï¼‰: ${name}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ“› Token nameï¼ˆä»£å¸åç§°ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–ä»£å¸ç¬¦å·
                    try {
                        const symbol = await tokenContract.symbol().call();
                        this.logEventDetail(`ğŸ·ï¸ Name(Symbol)ï¼ˆä»£å¸ç¬¦å·ï¼‰: ${symbol}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ·ï¸ Name(Symbol)ï¼ˆä»£å¸ç¬¦å·ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–æ€»ä¾›åº”é‡
                    try {
                        const totalSupply = await tokenContract.totalSupply().call();
                        let decimals = 18; // é»˜è®¤å€¼

                        // å°è¯•è·å–å°æ•°ä½æ•°
                        try {
                            const decimalResult = await tokenContract.decimals().call();
                            decimals = typeof decimalResult === 'bigint' ? Number(decimalResult) : parseInt(decimalResult);
                        } catch (e) {
                            // ä½¿ç”¨é»˜è®¤å€¼
                        }

                        let formattedSupply;
                        if (typeof totalSupply === 'bigint') {
                            const divisor = BigInt(10) ** BigInt(decimals);
                            const supplyInTokens = totalSupply / divisor;
                            formattedSupply = supplyInTokens.toLocaleString();
                        } else {
                            const supplyNum = parseFloat(totalSupply);
                            formattedSupply = (supplyNum / Math.pow(10, decimals)).toLocaleString();
                        }
                        this.logEventDetail(`ğŸ’° Supplyï¼ˆæ€»ä¾›åº”é‡ï¼‰: ${formattedSupply}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ’° Supplyï¼ˆæ€»ä¾›åº”é‡ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–ä»£å¸ç»æµå­¦é¢„è®¾
                    try {
                        const baseConfig = await tokenContract.baseConfig().call();
                        this.logEventDetail(`âš™ï¸ Tokenomic presetï¼ˆä»£å¸ç»æµå­¦é¢„è®¾ï¼‰:`, 'success');
                        this.logEventDetail(`  - ä¹°å…¥æ‰‹ç»­è´¹: ${baseConfig.feeBuy || baseConfig[0]}%`, 'info');
                        this.logEventDetail(`  - å–å‡ºæ‰‹ç»­è´¹: ${baseConfig.feeSell || baseConfig[1]}%`, 'info');
                        this.logEventDetail(`  - LPç‡ƒçƒ§å¯ç”¨: ${(baseConfig.lpBurnEnabled || baseConfig[2]) ? 'æ˜¯' : 'å¦'}`, 'info');
                        this.logEventDetail(`  - LPç‡ƒçƒ§é¢‘ç‡: ${baseConfig.lpBurnFrequency || baseConfig[3]}`, 'info');
                        this.logEventDetail(`  - LPç‡ƒçƒ§æ¯”ä¾‹: ${baseConfig.percentForLPBurn || baseConfig[4]}%`, 'info');
                    } catch (e) {
                        this.logEventDetail(`âš™ï¸ Tokenomic presetï¼ˆä»£å¸ç»æµå­¦é¢„è®¾ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                } catch (error) {
                    this.logEventDetail(`[ä»£å¸ä¿¡æ¯] è·å–å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async getPresaleDetails(presaleAddress) {
                try {
                    this.logEventDetail('=== ç¬¬ä¸€ç»„ - é¢„å”®é…ç½®ä¿¡æ¯ ===', 'success');
                    this.logEventDetail(`ğŸš€ è·å–é¢„å”®è¯¦ç»†ä¿¡æ¯: ${presaleAddress}`, 'info');

                    // ä½¿ç”¨åŠ è½½çš„å®Œæ•´presaleABIæˆ–åŸºç¡€ABI
                    const presaleABI = this.presaleABI || [
                        {"inputs":[],"name":"hardcap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"maxBuyPerWallet","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"presaleEthAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"tradeEthAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"maxTotalNum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"presaleMaxNum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"getLGEConfig","outputs":[
                            {"internalType":"uint256","name":"vestingDelay_","type":"uint256"},
                            {"internalType":"uint256","name":"vestingRate_","type":"uint256"},
                            {"internalType":"bool","name":"vestingEnabled_","type":"bool"},
                            {"internalType":"uint256","name":"backingShare_","type":"uint256"},
                            {"internalType":"address","name":"backingReceiver_","type":"address"},
                            {"internalType":"uint256","name":"startTime_","type":"uint256"},
                            {"internalType":"uint256","name":"hardcap_","type":"uint256"},
                            {"internalType":"uint256","name":"maxBuyPerWallet_","type":"uint256"}
                        ],"stateMutability":"view","type":"function"}
                    ];

                    const presaleContract = await this.tronWeb.contract(presaleABI, presaleAddress);

                    // è·å–Token for LGEï¼ˆé€šè¿‡äº‹ä»¶å·²è·å–ï¼‰
                    this.logEventDetail(`ğŸª™ Token for LGEï¼ˆæµåŠ¨æ€§ç”Ÿæˆäº‹ä»¶ä»£å¸ï¼‰: é¢„å”®åˆçº¦åœ°å€`, 'success');
                    this.logEventDetail(`ğŸ“ é¢„å”®åˆçº¦åœ°å€: ${presaleAddress}`, 'info');

                    // è·å–TST/TRXæ±‡ç‡
                    try {
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();
                        const tradeEthAmount = await presaleContract.tradeEthAmount().call();

                        const presaleAmount = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) : parseInt(presaleEthAmount);
                        const tradeAmount = typeof tradeEthAmount === 'bigint' ? Number(tradeEthAmount) : parseInt(tradeEthAmount);

                        const rate = presaleAmount / tradeAmount;
                        this.logEventDetail(`ğŸ’± TST/TRX æ±‡ç‡: 1 TRX = ${rate.toFixed(4)} TST`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ï¿½ TST/TRX æ±‡ç‡: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–Soft capï¼ˆéœ€è¦è®¡ç®—æˆ–æŸ¥æ‰¾ï¼‰
                    try {
                        const maxTotalNum = await presaleContract.maxTotalNum().call();
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();

                        const maxTotal = typeof maxTotalNum === 'bigint' ? Number(maxTotalNum) : parseInt(maxTotalNum);
                        const ethAmount = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) : parseInt(presaleEthAmount);

                        const softCap = (maxTotal * ethAmount) / 1e6; // è½¬æ¢ä¸ºTRX
                        this.logEventDetail(`ğŸ¯ Soft capï¼ˆè½¯é¡¶ï¼‰: ${softCap.toLocaleString()} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ¯ Soft capï¼ˆè½¯é¡¶ï¼‰: è®¡ç®—å¤±è´¥`, 'warning');
                    }

                    // è·å–Hard cap
                    try {
                        const hardcap = await presaleContract.hardcap().call();
                        const hardcapTRX = typeof hardcap === 'bigint' ? Number(hardcap) / 1e6 : parseInt(hardcap) / 1e6;
                        this.logEventDetail(`ğŸ¯ Hard capï¼ˆç¡¬é¡¶ï¼‰: ${hardcapTRX.toLocaleString()} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ¯ Hard capï¼ˆç¡¬é¡¶ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–Min buyï¼ˆé€šå¸¸æ˜¯presaleEthAmountï¼‰
                    try {
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();
                        const minBuy = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) / 1e6 : parseInt(presaleEthAmount) / 1e6;
                        this.logEventDetail(`ğŸ’° Min buyï¼ˆæœ€å°è´­ä¹°é‡ï¼‰: ${minBuy} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ’° Min buyï¼ˆæœ€å°è´­ä¹°é‡ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–Max buy
                    try {
                        const maxBuyPerWallet = await presaleContract.maxBuyPerWallet().call();
                        const maxBuy = typeof maxBuyPerWallet === 'bigint' ? Number(maxBuyPerWallet) / 1e6 : parseInt(maxBuyPerWallet) / 1e6;
                        this.logEventDetail(`ğŸ’° Max buyï¼ˆæœ€å¤§è´­ä¹°é‡ï¼‰: ${maxBuy} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`ğŸ’° Max buyï¼ˆæœ€å¤§è´­ä¹°é‡ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–Start time
                    try {
                        const startTime = await presaleContract.startTime().call();
                        const timestamp = typeof startTime === 'bigint' ? Number(startTime) : parseInt(startTime);
                        const startDate = new Date(timestamp * 1000);
                        this.logEventDetail(`â° Start timeï¼ˆå¼€å§‹æ—¶é—´ï¼‰: ${startDate.toLocaleString()}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`â° Start timeï¼ˆå¼€å§‹æ—¶é—´ï¼‰: è·å–å¤±è´¥`, 'warning');
                    }

                    // è·å–LGEé…ç½®ä¿¡æ¯
                    try {
                        const lgeConfig = await presaleContract.getLGEConfig().call();

                        // Vesting delay
                        const vestingDelay = typeof lgeConfig.vestingDelay_ === 'bigint' ? Number(lgeConfig.vestingDelay_) : parseInt(lgeConfig.vestingDelay_ || lgeConfig[0]);
                        this.logEventDetail(`â³ Vesting delayï¼ˆé‡Šæ”¾å»¶è¿Ÿï¼‰: ${vestingDelay} å¤©`, 'success');

                        // Vesting rate
                        const vestingRate = typeof lgeConfig.vestingRate_ === 'bigint' ? Number(lgeConfig.vestingRate_) : parseInt(lgeConfig.vestingRate_ || lgeConfig[1]);
                        this.logEventDetail(`ğŸ“Š Vesting rate(%)ï¼ˆé‡Šæ”¾æ¯”ä¾‹ï¼‰: ${vestingRate}%`, 'success');

                        // Vesting enabled
                        const vestingEnabled = lgeConfig.vestingEnabled_ || lgeConfig[2];
                        this.logEventDetail(`ğŸ”„ Vesting roundsï¼ˆé‡Šæ”¾è½®æ¬¡ï¼‰: ${vestingEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'success');

                        // Backing
                        const backingShare = typeof lgeConfig.backingShare_ === 'bigint' ? Number(lgeConfig.backingShare_) : parseInt(lgeConfig.backingShare_ || lgeConfig[3]);
                        let backingReceiver = lgeConfig.backingReceiver_ || lgeConfig[4];

                        // ç¡®ä¿åœ°å€æ˜¯Base58æ ¼å¼
                        if (backingReceiver && typeof backingReceiver === 'string' && backingReceiver.startsWith('0x')) {
                            try {
                                backingReceiver = this.tronWeb.address.fromHex(backingReceiver);
                            } catch (e) {
                                // å¦‚æœè½¬æ¢å¤±è´¥ï¼Œä¿æŒåŸæ ¼å¼
                            }
                        }

                        this.logEventDetail(`ğŸ¦ Backingï¼ˆèƒŒä¹¦/æ”¯æŒï¼‰: ${backingShare}% -> ${backingReceiver}`, 'success');

                    } catch (e) {
                        this.logEventDetail(`âš™ï¸ LGEé…ç½®ä¿¡æ¯: è·å–å¤±è´¥ - ${e.message}`, 'warning');
                    }

                } catch (error) {
                    this.logEventDetail(`[é¢„å”®ä¿¡æ¯] è·å–å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async displayPresaleConfigSummary(tokenAddress, presaleAddress) {
                try {
                    this.logEventDetail('=== è¡¥å……ä¿¡æ¯è·å– ===', 'info');

                    // è·å–TRXäº¤æ˜“å¯¹ä¿¡æ¯
                    if (tokenAddress) {
                        try {
                            const tokenContract = await this.tronWeb.contract(this.tokenABI, tokenAddress);
                            const pairTRX = await tokenContract.pairTRX().call();
                            this.logEventDetail(`ğŸ”— TRX pairï¼ˆTRXäº¤æ˜“å¯¹ï¼‰: ${pairTRX}`, 'success');
                        } catch (e) {
                            this.logEventDetail(`ğŸ”— TRX pairï¼ˆTRXäº¤æ˜“å¯¹ï¼‰: è·å–å¤±è´¥`, 'warning');
                        }
                    }

                    // è®¡ç®—End timeå’ŒDuration
                    if (presaleAddress) {
                        try {
                            const presaleContract = await this.tronWeb.contract(this.presaleABI, presaleAddress);
                            const startTime = await presaleContract.startTime().call();
                            const startTimestamp = typeof startTime === 'bigint' ? Number(startTime) : parseInt(startTime);

                            // å‡è®¾é¢„å”®æŒç»­æ—¶é—´ä¸º7å¤©ï¼ˆå¯ä»¥æ ¹æ®å®é™…åˆçº¦è°ƒæ•´ï¼‰
                            const durationDays = 7;
                            const endTimestamp = startTimestamp + (durationDays * 24 * 60 * 60);
                            const endDate = new Date(endTimestamp * 1000);

                            this.logEventDetail(`â° End timeï¼ˆç»“æŸæ—¶é—´ï¼‰: ${endDate.toLocaleString()}`, 'success');
                            this.logEventDetail(`â±ï¸ Durationï¼ˆæŒç»­æ—¶é—´ï¼‰: ${durationDays} å¤©`, 'success');
                        } catch (e) {
                            this.logEventDetail(`â° End timeï¼ˆç»“æŸæ—¶é—´ï¼‰: è®¡ç®—å¤±è´¥`, 'warning');
                            this.logEventDetail(`â±ï¸ Durationï¼ˆæŒç»­æ—¶é—´ï¼‰: è®¡ç®—å¤±è´¥`, 'warning');
                        }
                    }

                    this.logEventDetail('=== é¢„å”®é…ç½®ä¿¡æ¯è·å–å®Œæˆ ===', 'success');

                } catch (error) {
                    this.logEventDetail(`[è¡¥å……ä¿¡æ¯] è·å–å¤±è´¥: ${error.message}`, 'error');
                }
            }

            stop() {
                this.isRunning = false;

                // æ¸…ç†æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
                this.eventListeners.forEach((listener, index) => {
                    try {
                        if (listener.interval) {
                            // æ¸…ç†è½®è¯¢é—´éš”
                            clearInterval(listener.interval);
                            const eventName = listener.eventName || 'æœªçŸ¥';
                            const type = listener.type || 'è½®è¯¢';
                            logToConsole('info', `[åœæ­¢] å·²åœæ­¢ ${eventName} ${type}ç›‘å¬`);
                        } else if (listener.stop && typeof listener.stop === 'function') {
                            // æ¸…ç†åŸç”Ÿç›‘å¬å™¨
                            listener.stop();
                            logToConsole('info', `[åœæ­¢] å·²åœæ­¢åŸç”Ÿäº‹ä»¶ç›‘å¬å™¨ #${index}`);
                        } else if (listener.unwatch && typeof listener.unwatch === 'function') {
                            // æ¸…ç†watchç±»å‹ç›‘å¬å™¨
                            listener.unwatch();
                            logToConsole('info', `[åœæ­¢] å·²åœæ­¢watchäº‹ä»¶ç›‘å¬å™¨ #${index}`);
                        } else {
                            logToConsole('info', `[åœæ­¢] ç›‘å¬å™¨ #${index} ç±»å‹æœªçŸ¥ï¼Œè·³è¿‡æ¸…ç†`);
                        }
                    } catch (error) {
                        logToConsole('warning', `[åœæ­¢] æ¸…ç†ç›‘å¬å™¨ #${index} å¤±è´¥: ${error.message}`);
                    }
                });

                this.eventListeners = [];
                this.stopPolling();
                logToConsole('info', '[åœæ­¢] æ‰€æœ‰äº‹ä»¶ç›‘å¬å·²åœæ­¢');
            }

            async handleLGEConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', 'âš™ï¸ æ£€æµ‹åˆ°LGEé…ç½®è®¾ç½®äº‹ä»¶ï¼');

                    // è§£æLGEé…ç½®å‚æ•°
                    if (eventParams) {
                        // æ ¹æ®åˆçº¦å®šä¹‰ï¼ŒLGEConfigSetå¯èƒ½åŒ…å«ä»¥ä¸‹å‚æ•°
                        const configKeys = [
                            'lgeAddress', 'lgeContract', 'address',
                            'duration', 'period', 'time',
                            'minContribution', 'maxContribution', 'contribution',
                            'rate', 'price', 'exchangeRate'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // è·³è¿‡æ•°å­—ç´¢å¼•

                            let displayValue = value;
                            let label = key;

                            // æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRONåœ°å€
                                displayValue = value;
                                label = `ğŸ“ ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // æ•°å­—å€¼
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('time') || key.toLowerCase().includes('duration')) {
                                    // æ—¶é—´æˆ³
                                    displayValue = new Date(Number(numValue) * 1000).toLocaleString();
                                    label = `â° ${key}`;
                                } else if (key.toLowerCase().includes('contribution') || key.toLowerCase().includes('amount')) {
                                    // é‡‘é¢
                                    displayValue = (Number(numValue) / 1e6).toLocaleString() + ' TRX';
                                    label = `ğŸ’° ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `ğŸ”¢ ${key}`;
                                }
                            } else {
                                label = `ğŸ“‹ ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[LGEConfigSet] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            async handleVestingConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', 'ğŸ”’ æ£€æµ‹åˆ°å½’å±é…ç½®è®¾ç½®äº‹ä»¶ï¼');

                    // è§£æå½’å±é…ç½®å‚æ•°
                    if (eventParams) {
                        const configKeys = [
                            'vestingContract', 'beneficiary', 'address',
                            'cliff', 'duration', 'period',
                            'amount', 'totalAmount', 'vestingAmount',
                            'startTime', 'cliffTime', 'endTime'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // è·³è¿‡æ•°å­—ç´¢å¼•

                            let displayValue = value;
                            let label = key;

                            // æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRONåœ°å€
                                displayValue = value;
                                label = `ğŸ“ ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // æ•°å­—å€¼
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('time') || key.toLowerCase().includes('cliff')) {
                                    // æ—¶é—´æˆ³
                                    displayValue = new Date(Number(numValue) * 1000).toLocaleString();
                                    label = `â° ${key}`;
                                } else if (key.toLowerCase().includes('amount')) {
                                    // ä»£å¸æ•°é‡
                                    displayValue = (Number(numValue) / 1e18).toLocaleString() + ' ä»£å¸';
                                    label = `ğŸ’° ${key}`;
                                } else if (key.toLowerCase().includes('duration') || key.toLowerCase().includes('period')) {
                                    // æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
                                    const days = Number(numValue) / (24 * 60 * 60);
                                    displayValue = `${days.toFixed(1)} å¤©`;
                                    label = `â³ ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `ğŸ”¢ ${key}`;
                                }
                            } else {
                                label = `ğŸ“‹ ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[VestingConfigSet] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            async handleBackingConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', 'ğŸ›¡ï¸ æ£€æµ‹åˆ°æ”¯æŒé…ç½®è®¾ç½®äº‹ä»¶ï¼');

                    // è§£ææ”¯æŒé…ç½®å‚æ•°
                    if (eventParams) {
                        const configKeys = [
                            'backingToken', 'collateralToken', 'token',
                            'backingRatio', 'collateralRatio', 'ratio',
                            'minBacking', 'maxBacking', 'backing',
                            'oracle', 'priceOracle', 'priceFeed'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // è·³è¿‡æ•°å­—ç´¢å¼•

                            let displayValue = value;
                            let label = key;

                            // æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRONåœ°å€
                                displayValue = value;
                                label = `ğŸ“ ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // æ•°å­—å€¼
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('ratio')) {
                                    // æ¯”ç‡ï¼ˆé€šå¸¸æ˜¯ç™¾åˆ†æ¯”ï¼‰
                                    displayValue = (Number(numValue) / 100).toFixed(2) + '%';
                                    label = `ğŸ“Š ${key}`;
                                } else if (key.toLowerCase().includes('backing') || key.toLowerCase().includes('amount')) {
                                    // æ”¯æŒé‡‘é¢
                                    displayValue = (Number(numValue) / 1e18).toLocaleString() + ' ä»£å¸';
                                    label = `ğŸ’° ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `ğŸ”¢ ${key}`;
                                }
                            } else {
                                label = `ğŸ“‹ ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `ğŸ“¦ åŒºå—å·: ${blockNumber}`);
                    logToConsole('info', `ğŸ”— äº¤æ˜“ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[BackingConfigSet] å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            // æµ‹è¯•æ–¹æ³•ï¼šæ¨¡æ‹Ÿäº‹ä»¶æ•°æ®
            async testEventHandling() {
                logToConsole('info', '[æµ‹è¯•] å¼€å§‹æµ‹è¯•äº‹ä»¶å¤„ç†é€»è¾‘...');

                // æ¨¡æ‹Ÿ TokenPresalePairCreated äº‹ä»¶
                const mockTokenPresaleEvent = {
                    result: {
                        token: 'TNmNmMMVS8BmWgTem7HExyjru1bv21sKRC',
                        presale: 'TS6bcFFQuooYFmrufqd79qM6FSdEpY9gee'
                    },
                    block: 12345678,
                    transaction: 'abc123def456789'
                };

                logToConsole('info', '[æµ‹è¯•] æ¨¡æ‹Ÿ TokenPresalePairCreated äº‹ä»¶...');
                await this.handleEvent('TokenPresalePairCreated', mockTokenPresaleEvent);

                // æ¨¡æ‹Ÿ OwnershipTransferred äº‹ä»¶
                const mockOwnershipEvent = {
                    result: {
                        previousOwner: 'TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH',
                        newOwner: 'TBy2vsVgN6XYi7uVL54vvWYEcueAUmAdEu'
                    },
                    block: 12345679,
                    transaction: 'def456ghi789abc'
                };

                logToConsole('info', '[æµ‹è¯•] æ¨¡æ‹Ÿ OwnershipTransferred äº‹ä»¶...');
                await this.handleEvent('OwnershipTransferred', mockOwnershipEvent);

                // æ¨¡æ‹Ÿ LGEConfigSet äº‹ä»¶
                const mockLGEConfigEvent = {
                    result: {
                        lgeAddress: 'TLGEAddress123456789012345678901234567890',
                        duration: '2592000', // 30å¤©
                        minContribution: '1000000', // 1 TRX
                        maxContribution: '10000000000' // 10,000 TRX
                    },
                    block: 12345680,
                    transaction: 'lge123config456'
                };

                logToConsole('info', '[æµ‹è¯•] æ¨¡æ‹Ÿ LGEConfigSet äº‹ä»¶...');
                await this.handleEvent('LGEConfigSet', mockLGEConfigEvent);

                // æ¨¡æ‹Ÿ VestingConfigSet äº‹ä»¶
                const mockVestingConfigEvent = {
                    result: {
                        beneficiary: 'TBeneficiary123456789012345678901234567',
                        cliff: '7776000', // 90å¤©
                        duration: '31536000', // 365å¤©
                        amount: '1000000000000000000000' // 1000 ä»£å¸
                    },
                    block: 12345681,
                    transaction: 'vest123config456'
                };

                logToConsole('info', '[æµ‹è¯•] æ¨¡æ‹Ÿ VestingConfigSet äº‹ä»¶...');
                await this.handleEvent('VestingConfigSet', mockVestingConfigEvent);

                // æ¨¡æ‹Ÿ BackingConfigSet äº‹ä»¶
                const mockBackingConfigEvent = {
                    result: {
                        backingToken: 'TBackingToken123456789012345678901234',
                        backingRatio: '8000', // 80%
                        minBacking: '100000000000000000000', // 100 ä»£å¸
                        oracle: 'TOracle123456789012345678901234567890'
                    },
                    block: 12345682,
                    transaction: 'back123config456'
                };

                logToConsole('info', '[æµ‹è¯•] æ¨¡æ‹Ÿ BackingConfigSet äº‹ä»¶...');
                await this.handleEvent('BackingConfigSet', mockBackingConfigEvent);

                logToConsole('success', '[æµ‹è¯•] æ‰€æœ‰äº‹ä»¶å¤„ç†æµ‹è¯•å®Œæˆï¼');
            }

            // æ‰‹åŠ¨æ£€æŸ¥æœ€è¿‘çš„äº‹ä»¶
            async checkRecentEvents() {
                try {
                    logToConsole('info', '[æ£€æŸ¥] å¼€å§‹æ£€æŸ¥æœ€è¿‘çš„äº‹ä»¶...');

                    const eventNames = [
                        'TokenPresalePairCreated',
                        'OwnershipTransferred',
                        'TokenPresaleLinked',
                        'LGEConfigSet',
                        'VestingConfigSet',
                        'BackingConfigSet'
                    ];

                    for (const eventName of eventNames) {
                        try {
                            logToConsole('info', `[æ£€æŸ¥] æŸ¥è¯¢ ${eventName} äº‹ä»¶...`);

                            // æ–¹æ³•1: ä½¿ç”¨ trx.getEventResult
                            if (this.tronWeb.trx && this.tronWeb.trx.getEventResult) {
                                const events = await this.tronWeb.trx.getEventResult(this.coordinatorAddress, {
                                    eventName: eventName,
                                    size: 5,
                                    onlyConfirmed: false
                                });

                                if (events && events.length > 0) {
                                    logToConsole('success', `[æ£€æŸ¥] æ‰¾åˆ° ${events.length} ä¸ª ${eventName} äº‹ä»¶`);
                                    events.forEach((event, index) => {
                                        logToConsole('info', `[æ£€æŸ¥] äº‹ä»¶ ${index + 1}: ${JSON.stringify(event, null, 2)}`);
                                    });
                                } else {
                                    logToConsole('info', `[æ£€æŸ¥] æœªæ‰¾åˆ° ${eventName} äº‹ä»¶`);
                                }
                            }

                            // æ–¹æ³•2: ä½¿ç”¨ getEventResult
                            else if (this.tronWeb.getEventResult) {
                                const events = await this.tronWeb.getEventResult(this.coordinatorAddress, {
                                    eventName: eventName,
                                    size: 5,
                                    onlyConfirmed: false
                                });

                                if (events && events.length > 0) {
                                    logToConsole('success', `[æ£€æŸ¥] æ‰¾åˆ° ${events.length} ä¸ª ${eventName} äº‹ä»¶`);
                                    events.forEach((event, index) => {
                                        logToConsole('info', `[æ£€æŸ¥] äº‹ä»¶ ${index + 1}: ${JSON.stringify(event, null, 2)}`);
                                    });
                                } else {
                                    logToConsole('info', `[æ£€æŸ¥] æœªæ‰¾åˆ° ${eventName} äº‹ä»¶`);
                                }
                            }

                        } catch (eventError) {
                            logToConsole('warning', `[æ£€æŸ¥] æŸ¥è¯¢ ${eventName} å¤±è´¥: ${eventError.message}`);
                        }
                    }

                    logToConsole('success', '[æ£€æŸ¥] æœ€è¿‘äº‹ä»¶æ£€æŸ¥å®Œæˆ');

                } catch (error) {
                    logToConsole('error', `[æ£€æŸ¥] æ£€æŸ¥æœ€è¿‘äº‹ä»¶å¤±è´¥: ${error.message}`);
                }
            }

            getStatus() {
                return {
                    isRunning: this.isRunning,
                    eventCount: this.eventCount,
                    errorCount: this.errorCount
                };
            }
        }

        // é¡µé¢åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // åˆå§‹åŒ–æ—¥å¿—è¿‡æ»¤å™¨
                initLogFilters();

                logToConsole('info', 'é¡µé¢åŠ è½½å®Œæˆ', 'é¡µé¢');
                eventMonitor = new SimpleEventMonitor();
                window.eventMonitor = eventMonitor; // æš´éœ²åˆ°å…¨å±€ä¾›è°ƒè¯•

                logToConsole('success', 'äº‹ä»¶ç›‘å¬å™¨å·²åˆå§‹åŒ–', 'ç³»ç»Ÿ');
            } catch (error) {
                console.error('é¡µé¢åˆå§‹åŒ–å¤±è´¥:', error);
                logToConsole('error', `é¡µé¢åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'ç³»ç»Ÿ');
            }
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', function(event) {
            logToConsole('error', `JavaScripté”™è¯¯: ${event.error?.message || event.message}`, 'ç³»ç»Ÿé”™è¯¯');
            console.error('å…¨å±€é”™è¯¯:', event.error);
        });

        window.addEventListener('unhandledrejection', function(event) {
            logToConsole('error', `æœªå¤„ç†çš„Promiseæ‹’ç»: ${event.reason?.message || event.reason}`, 'ç³»ç»Ÿé”™è¯¯');
            console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
        });

        // è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨æ‰§è¡Œå¼‚æ­¥æ“ä½œ
        async function safeExecute(operation, operationName) {
            try {
                return await operation();
            } catch (error) {
                logToConsole('error', `${operationName}å¤±è´¥: ${error.message}`, 'é”™è¯¯');
                console.error(`${operationName}å¤±è´¥:`, error);
                throw error;
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–åœ°å€æ˜¾ç¤º
        function formatAddress(address) {
            if (!address || typeof address !== 'string') return 'æœªçŸ¥åœ°å€';
            if (address.length <= 10) return address;
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–æ•°å­—
        function formatNumber(num, decimals = 2) {
            if (typeof num === 'bigint') {
                return num.toLocaleString();
            }
            if (typeof num === 'string') {
                const parsed = parseFloat(num);
                return isNaN(parsed) ? num : parsed.toLocaleString(undefined, { maximumFractionDigits: decimals });
            }
            if (typeof num === 'number') {
                return num.toLocaleString(undefined, { maximumFractionDigits: decimals });
            }
            return String(num);
        }

        async function startMonitoring() {
            if (!eventMonitor) {
                logToConsole('error', '[é”™è¯¯] äº‹ä»¶ç›‘å¬å™¨æœªåˆ›å»º');
                return;
            }

            try {
                document.getElementById('startBtn').disabled = true;
                document.getElementById('connectionStatus').textContent = 'è¿æ¥ä¸­...';

                logToConsole('info', 'å¼€å§‹å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨...', 'å¯åŠ¨');

                await safeExecute(
                    () => eventMonitor.initialize(),
                    'åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨'
                );

                await safeExecute(
                    () => eventMonitor.start(),
                    'å¯åŠ¨äº‹ä»¶ç›‘å¬'
                );

                document.getElementById('stopBtn').disabled = false;
                document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥';

                startTime = Date.now();
                isMonitoring = true;

                // å¯åŠ¨è¿è¡Œæ—¶é—´è®¡æ—¶å™¨
                if (uptimeTimer) clearInterval(uptimeTimer);
                uptimeTimer = setInterval(updateUptime, 1000);

                logToConsole('success', 'äº‹ä»¶ç›‘å¬å™¨å¯åŠ¨æˆåŠŸï¼', 'å¯åŠ¨');

            } catch (error) {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('connectionStatus').textContent = 'è¿æ¥å¤±è´¥';
                logToConsole('error', `å¯åŠ¨å¤±è´¥: ${error.message}`, 'å¯åŠ¨');
                isMonitoring = false;
            }
        }

        function stopMonitoring() {
            if (eventMonitor) {
                eventMonitor.stop();
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('connectionStatus').textContent = 'å·²æ–­å¼€';
            
            isMonitoring = false;
            
            if (uptimeTimer) {
                clearInterval(uptimeTimer);
                uptimeTimer = null;
            }
        }

        async function testConnection() {
            logToConsole('info', '[æµ‹è¯•] å¼€å§‹è¿æ¥æµ‹è¯•...');
            
            try {
                if (typeof window.TronWeb === 'undefined') {
                    throw new Error('TronWebåº“æœªåŠ è½½');
                }

                const tronWeb = new window.TronWeb({
                    fullHost: 'https://nile.trongrid.io'
                });

                const currentBlock = await tronWeb.trx.getCurrentBlock();
                logToConsole('success', `[æµ‹è¯•] è¿æ¥æˆåŠŸï¼Œå½“å‰åŒºå—: ${currentBlock.block_header.raw_data.number}`);
                
                // æµ‹è¯•åˆçº¦åœ°å€
                const isValid = tronWeb.isAddress('TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc');
                logToConsole('success', `[æµ‹è¯•] åˆçº¦åœ°å€æœ‰æ•ˆæ€§: ${isValid}`);
                
            } catch (error) {
                logToConsole('error', `[æµ‹è¯•] è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        function clearConsole() {
            document.getElementById('consoleOutput').innerHTML = '';
            logToConsole('info', '[æ¸…ç©º] æ§åˆ¶å°å·²æ¸…ç©º');
        }

        function updateUptime() {
            if (!startTime) return;
            
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / (1000 * 60 * 60));
            const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsed % (1000 * 60)) / 1000);
            
            const uptimeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('uptime').textContent = uptimeStr;
        }

        function logToConsole(type, message) {
            const consoleOutput = document.getElementById('consoleOutput');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // æ›´æ–°é”™è¯¯è®¡æ•°
            if (type === 'error') {
                const errorCountEl = document.getElementById('errorCount');
                const currentCount = parseInt(errorCountEl.textContent) || 0;
                errorCountEl.textContent = currentCount + 1;
            }
            
            // é™åˆ¶æ—¥å¿—æ¡æ•°
            const logEntries = consoleOutput.querySelectorAll('.log-entry');
            if (logEntries.length > 200) {
                logEntries[0].remove();
            }
        }

        // æ£€æŸ¥æœ€æ–°é¢„å”®äº‹ä»¶åŠŸèƒ½
        async function checkLatestPresaleEvents() {
            try {
                logToConsole('info', 'ğŸ“Š å¼€å§‹æ£€æŸ¥æœ€æ–°é¢„å”®äº‹ä»¶...', 'æ£€æŸ¥');

                if (!eventMonitor) {
                    logToConsole('error', 'äº‹ä»¶ç›‘å¬å™¨æœªåˆå§‹åŒ–ï¼Œè¯·å…ˆå¯åŠ¨ç›‘å¬', 'æ£€æŸ¥');
                    return;
                }

                if (!eventMonitor.tronWeb) {
                    logToConsole('error', 'TronWebæœªåˆå§‹åŒ–ï¼Œè¯·å…ˆæˆåŠŸå¯åŠ¨ç›‘å¬å™¨', 'æ£€æŸ¥');
                    return;
                }

                const contractAddress = eventMonitor.coordinatorAddress;
                logToConsole('info', `ğŸ” æ­£åœ¨æ£€æŸ¥åˆçº¦åœ°å€: ${contractAddress}`, 'æ£€æŸ¥');

                try {
                    // ä½¿ç”¨TronWebçš„getEventResultæ–¹æ³•è·å–æœ€æ–°äº‹ä»¶
                    let events;

                    // å°è¯•ä¸åŒçš„APIè°ƒç”¨æ–¹å¼
                    if (eventMonitor.tronWeb.getEventResult) {
                        events = await eventMonitor.tronWeb.getEventResult(contractAddress, {
                            eventName: 'TokenPresalePairCreated',
                            size: 5,
                            onlyConfirmed: true
                        });
                    } else if (eventMonitor.tronWeb.trx && eventMonitor.tronWeb.trx.getEventResult) {
                        events = await eventMonitor.tronWeb.trx.getEventResult(contractAddress, {
                            eventName: 'TokenPresalePairCreated',
                            size: 5,
                            onlyConfirmed: true
                        });
                    } else {
                        throw new Error('getEventResultæ–¹æ³•ä¸å¯ç”¨');
                    }

                    if (events && events.length > 0) {
                        logToConsole('success', `ğŸ‰ å‘ç° ${events.length} ä¸ªTokenPresalePairCreatedäº‹ä»¶`, 'æ£€æŸ¥');

                        // å¤„ç†æœ€æ–°çš„äº‹ä»¶
                        for (let i = 0; i < Math.min(events.length, 2); i++) {
                            const event = events[i];
                            logToConsole('info', `ğŸ“‹ å¤„ç†ç¬¬ ${i + 1} ä¸ªäº‹ä»¶...`, 'æ£€æŸ¥');

                            // è°ƒç”¨äº‹ä»¶å¤„ç†å‡½æ•°
                            await eventMonitor.handleTokenPresalePairCreated(
                                event.result,
                                event.block_number,
                                event.transaction_id
                            );
                        }

                        logToConsole('success', 'âœ… æœ€æ–°é¢„å”®äº‹ä»¶æ£€æŸ¥å®Œæˆ', 'æ£€æŸ¥');
                    } else {
                        logToConsole('info', 'ğŸ“­ æœªå‘ç°TokenPresalePairCreatedäº‹ä»¶', 'æ£€æŸ¥');
                        logToConsole('info', 'ğŸ’¡ æç¤ºï¼šå¯èƒ½è¯¥åˆçº¦è¿˜æ²¡æœ‰åˆ›å»ºé¢„å”®é…å¯¹ï¼Œæˆ–è€…äº‹ä»¶è¿˜æœªç¡®è®¤', 'æ£€æŸ¥');
                    }

                } catch (eventError) {
                    logToConsole('warning', `è·å–äº‹ä»¶å¤±è´¥: ${eventError.message}`, 'æ£€æŸ¥');

                    // å°è¯•å¤‡ç”¨æ–¹æ³•ï¼šæ£€æŸ¥åˆçº¦æ˜¯å¦å­˜åœ¨
                    try {
                        const contractInfo = await eventMonitor.tronWeb.trx.getContract(contractAddress);
                        if (contractInfo && contractInfo.contract_address) {
                            logToConsole('success', `âœ… åˆçº¦åœ°å€æœ‰æ•ˆ: ${contractInfo.contract_address}`, 'æ£€æŸ¥');
                            logToConsole('info', 'ğŸ’¡ åˆçº¦å­˜åœ¨ä½†å¯èƒ½è¿˜æ²¡æœ‰TokenPresalePairCreatedäº‹ä»¶', 'æ£€æŸ¥');
                        }
                    } catch (contractError) {
                        logToConsole('error', `åˆçº¦åœ°å€éªŒè¯å¤±è´¥: ${contractError.message}`, 'æ£€æŸ¥');
                    }
                }

            } catch (error) {
                logToConsole('error', `æ£€æŸ¥å¤±è´¥: ${error.message}`, 'æ£€æŸ¥');
            }
        }
    </script>
</body>
</html>
