<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>简化版事件监听器</title>
    
    <!-- 加载TronWeb库 -->
    <script src="https://unpkg.com/tronweb@5.3.2/dist/TronWeb.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .status-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: #3b82f6;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: #2563eb;
        }

        .btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }

        .console-output {
            background: #000000;
            border: 1px solid #333333;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .console-header {
            position: sticky;
            top: 0;
            background: #1a1a1a;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .log-filters {
            display: flex;
            gap: 5px;
        }

        .filter-btn {
            padding: 2px 8px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .filter-btn:hover {
            background: #555;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 4px solid transparent;
            position: relative;
            transition: all 0.2s ease;
            word-wrap: break-word;
            background: rgba(255, 255, 255, 0.02);
        }

        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05) !important;
            transform: translateX(2px);
        }

        .log-timestamp {
            font-size: 10px;
            opacity: 0.6;
            margin-right: 8px;
            color: #888;
        }

        .log-category {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 8px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .log-info {
            color: #3b82f6;
            border-left-color: #3b82f6;
            background: rgba(59, 130, 246, 0.08);
        }

        .log-info .log-category {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .log-success {
            color: #10b981;
            border-left-color: #10b981;
            background: rgba(16, 185, 129, 0.08);
        }

        .log-success .log-category {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .log-warning {
            color: #f59e0b;
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.08);
        }

        .log-warning .log-category {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .log-error {
            color: #ef4444;
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.08);
            animation: errorPulse 0.5s ease-in-out;
        }

        .log-error .log-category {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .log-event {
            color: #8b5cf6;
            border-left-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.08);
            font-weight: bold;
            border: 1px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
        }

        .log-event .log-category {
            background: rgba(139, 92, 246, 0.2);
            color: #8b5cf6;
        }

        .log-debug {
            color: #90a4ae;
            border-left-color: #90a4ae;
            background: rgba(144, 164, 174, 0.05);
            font-size: 11px;
        }

        .log-debug .log-category {
            background: rgba(144, 164, 174, 0.2);
            color: #90a4ae;
        }

        @keyframes errorPulse {
            0% { background: rgba(239, 68, 68, 0.08); }
            50% { background: rgba(239, 68, 68, 0.2); }
            100% { background: rgba(239, 68, 68, 0.08); }
        }

        .event-group {
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(139, 92, 246, 0.05);
        }

        .event-header {
            font-weight: bold;
            color: #8b5cf6;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }

        .event-details {
            margin-left: 15px;
        }

        .hidden {
            display: none !important;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-label {
            display: block;
            color: #9ca3af;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .status-value {
            display: block;
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎧 简化版 TRON 事件监听器</h1>
            <p>监听 CoordinatorFactory 合约事件</p>
            <p style="font-size: 14px; color: #9ca3af;">合约地址: TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc</p>
        </div>

        <div class="status-panel">
            <div class="status-grid">
                <div class="status-item">
                    <span class="status-label">连接状态</span>
                    <span class="status-value" id="connectionStatus">未连接</span>
                </div>
                <div class="status-item">
                    <span class="status-label">事件总数</span>
                    <span class="status-value" id="eventCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">错误次数</span>
                    <span class="status-value" id="errorCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">运行时间</span>
                    <span class="status-value" id="uptime">00:00:00</span>
                </div>
            </div>

            <div class="controls">
                <button class="btn" id="startBtn" onclick="startMonitoring()">🚀 启动监听</button>
                <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>🛑 停止监听</button>
                <button class="btn" onclick="clearConsole()">🧹 清空日志</button>
                <button class="btn" onclick="testConnection()">🔗 测试连接</button>
                <button class="btn" onclick="eventMonitor && eventMonitor.testEventHandling()">🧪 测试事件处理</button>
                <button class="btn" onclick="eventMonitor && eventMonitor.checkRecentEvents()">🔍 检查最近事件</button>
                <button class="btn" onclick="checkLatestPresaleEvents()">📊 检查最新预售事件</button>
            </div>
        </div>

        <div class="status-panel">
            <h3>📝 控制台输出</h3>
            <div class="console-output" id="consoleOutput">
                <div class="console-header">
                    <div class="log-filters">
                        <button class="filter-btn active" data-filter="all">全部</button>
                        <button class="filter-btn" data-filter="event">事件</button>
                        <button class="filter-btn" data-filter="success">成功</button>
                        <button class="filter-btn" data-filter="error">错误</button>
                        <button class="filter-btn" data-filter="warning">警告</button>
                        <button class="filter-btn" data-filter="info">信息</button>
                    </div>
                    <div style="font-size: 11px; color: #888;">
                        <span id="logCount">0</span> 条日志
                        <button onclick="clearConsole()" style="margin-left: 10px; padding: 2px 6px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer;">清空</button>
                    </div>
                </div>
                <div id="logContainer">
                    <div class="log-entry log-info">
                        <span class="log-timestamp">[00:00:00]</span>
                        <span class="log-category">初始化</span>
                        简化版事件监听器已加载
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventMonitor = null;
        let startTime = null;
        let uptimeTimer = null;
        let isMonitoring = false;
        let logCounter = 0;
        let logFilters = {
            all: true,
            event: true,
            success: true,
            error: true,
            warning: true,
            info: true,
            debug: true
        };

        // 改进的日志函数
        function logToConsole(type, message, category = null) {
            try {
                logCounter++;
                const logContainer = document.getElementById('logContainer');
                const logCountElement = document.getElementById('logCount');

                if (!logContainer) {
                    console.error('日志容器未找到');
                    return;
                }

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.setAttribute('data-type', type);

                // 添加时间戳
                const timestamp = new Date().toLocaleTimeString();
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'log-timestamp';
                timestampSpan.textContent = `[${timestamp}]`;
                logEntry.appendChild(timestampSpan);

                // 添加分类标签
                if (category) {
                    const categorySpan = document.createElement('span');
                    categorySpan.className = 'log-category';
                    categorySpan.textContent = category;
                    logEntry.appendChild(categorySpan);
                }

                // 添加消息内容
                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;
                logEntry.appendChild(messageSpan);

                // 检查过滤器
                if (!logFilters[type] && !logFilters.all) {
                    logEntry.classList.add('hidden');
                }

                logContainer.appendChild(logEntry);

                // 更新日志计数
                if (logCountElement) {
                    logCountElement.textContent = logCounter;
                }

                // 自动滚动到底部
                const consoleOutput = document.getElementById('consoleOutput');
                if (consoleOutput) {
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }

                // 限制日志数量，避免内存溢出
                const maxLogs = 1000;
                const allLogs = logContainer.children;
                if (allLogs.length > maxLogs) {
                    for (let i = 0; i < allLogs.length - maxLogs; i++) {
                        logContainer.removeChild(allLogs[i]);
                    }
                }

            } catch (error) {
                console.error('日志记录失败:', error);
            }
        }

        // 日志过滤功能
        function initLogFilters() {
            try {
                const filterButtons = document.querySelectorAll('.filter-btn');
                filterButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        const filter = this.getAttribute('data-filter');

                        // 更新按钮状态
                        filterButtons.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');

                        // 更新过滤器状态
                        Object.keys(logFilters).forEach(key => {
                            logFilters[key] = (filter === 'all' || key === filter);
                        });

                        // 应用过滤器
                        applyLogFilters();
                    });
                });
            } catch (error) {
                console.error('初始化日志过滤器失败:', error);
            }
        }

        function applyLogFilters() {
            try {
                const logEntries = document.querySelectorAll('.log-entry');
                logEntries.forEach(entry => {
                    const type = entry.getAttribute('data-type');
                    if (logFilters.all || logFilters[type]) {
                        entry.classList.remove('hidden');
                    } else {
                        entry.classList.add('hidden');
                    }
                });
            } catch (error) {
                console.error('应用日志过滤器失败:', error);
            }
        }

        // 清空控制台
        function clearConsole() {
            try {
                const logContainer = document.getElementById('logContainer');
                const logCountElement = document.getElementById('logCount');

                if (logContainer) {
                    logContainer.innerHTML = '';
                }

                if (logCountElement) {
                    logCountElement.textContent = '0';
                }

                logCounter = 0;
                logToConsole('info', '控制台已清空', '系统');
            } catch (error) {
                console.error('清空控制台失败:', error);
            }
        }

        // 简化的事件监听器
        class SimpleEventMonitor {
            constructor() {
                this.tronWeb = null;
                this.isRunning = false;
                this.eventCount = 0;
                this.errorCount = 0;
                this.coordinatorAddress = 'TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc';
                this.contract = null;
                this.eventListeners = [];
                this.pollingInterval = null;
                this.lastBlockNumber = 0;
                
                // 加载完整的CoordinatorFactory ABI
                this.coordinatorABI = null; // 将通过fetch加载
            }

            async initialize() {
                try {
                    logToConsole('info', '开始初始化TronWeb...', '初始化');

                    // 检查TronWeb是否可用
                    if (typeof window.TronWeb === 'undefined') {
                        throw new Error('TronWeb库未加载');
                    }

                    // 加载ABI文件
                    await this.loadABI();

                    // 尝试使用TronLink
                    if (window.tronWeb && window.tronWeb.ready) {
                        this.tronWeb = window.tronWeb;
                        logToConsole('success', '使用TronLink提供的TronWeb', 'TronWeb');
                    } else {
                        // 使用公共节点 - 修复构造函数调用
                        this.tronWeb = new window.TronWeb(
                            'https://api.nileex.io',  // fullNode
                            'https://api.nileex.io',  // solidityNode
                            'https://api.nileex.io'   // eventServer
                        );
                        logToConsole('success', '使用Nile测试网节点连接', 'TronWeb');
                    }

                    // 测试连接
                    const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                    logToConsole('success', `当前区块: ${currentBlock.block_header.raw_data.number}`, '连接');

                    // 检测 TronWeb 功能
                    this.detectTronWebCapabilities();

                    // 跳过合约实例创建，直接使用TronWeb API
                    logToConsole('success', `TronWeb初始化成功，跳过合约实例创建`, '合约');
                    logToConsole('info', `📍 监听合约地址: ${this.coordinatorAddress}`, '合约');
                    logToConsole('info', `🎯 目标事件: TokenPresalePairCreated`, '合约');

                    return true;

                } catch (error) {
                    logToConsole('error', `[初始化] 失败: ${error.message}`);
                    this.errorCount++;
                    throw error;
                }
            }

            detectTronWebCapabilities() {
                logToConsole('info', '[检测] 开始检测 TronWeb 功能...');

                // 检测版本
                if (this.tronWeb.version) {
                    logToConsole('info', `[检测] TronWeb 版本: ${this.tronWeb.version}`);
                } else {
                    logToConsole('info', `[检测] TronWeb 版本: 未知`);
                }

                // 检测事件相关API
                const eventAPIs = [
                    'getEventResult',
                    'getEventByTransactionID',
                    'event'
                ];

                eventAPIs.forEach(api => {
                    const exists = !!this.tronWeb[api];
                    logToConsole('info', `[检测] ${api}: ${exists ? '✓ 可用' : '✗ 不可用'}`);

                    if (api === 'event' && exists) {
                        try {
                            const eventMethods = Object.keys(this.tronWeb.event || {});
                            logToConsole('info', `[检测] event 子方法: ${eventMethods.join(', ')}`);
                        } catch (e) {
                            logToConsole('warning', `[检测] 无法检测 event 子方法: ${e.message}`);
                        }
                    }
                });

                // 检测其他可能的事件相关方法
                const otherMethods = ['contract', 'trx'];
                otherMethods.forEach(method => {
                    const exists = !!this.tronWeb[method];
                    logToConsole('info', `[检测] ${method}: ${exists ? '✓ 可用' : '✗ 不可用'}`);
                });

                // 检测 TronWeb 的具体类型
                logToConsole('info', `[检测] TronWeb 构造函数: ${this.tronWeb.constructor.name}`);
                logToConsole('info', `[检测] TronWeb 原型链: ${Object.getPrototypeOf(this.tronWeb).constructor.name}`);
            }

            async loadABI() {
                try {
                    logToConsole('info', '[ABI] 加载合约ABI...');

                    // 尝试加载完整的ABI文件
                    try {
                        const coordinatorResponse = await fetch('./src/tron/contracts/abis/CoordinatorFactoryABI.json');
                        const presaleResponse = await fetch('./src/tron/contracts/abis/presaleABI.json');
                        const tokenResponse = await fetch('./src/tron/contracts/abis/tokenABI.json');

                        if (coordinatorResponse.ok && presaleResponse.ok && tokenResponse.ok) {
                            this.coordinatorABI = await coordinatorResponse.json();
                            this.presaleABI = await presaleResponse.json();
                            this.tokenABI = await tokenResponse.json();
                            logToConsole('success', '[ABI] 完整ABI文件加载成功');
                            return;
                        }
                    } catch (fetchError) {
                        logToConsole('warning', `[ABI] 无法加载完整ABI文件: ${fetchError.message}`);
                    }

                    // 使用基础的事件ABI作为备用
                    this.coordinatorABI = [
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "presale", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "creator", "type": "address"},
                                {"indexed": false, "internalType": "uint256", "name": "totalSupply", "type": "uint256"}
                            ],
                            "name": "TokenPresalePairCreated",
                            "type": "event"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "previousOwner", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "newOwner", "type": "address"}
                            ],
                            "name": "OwnershipTransferred",
                            "type": "event"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                                {"indexed": true, "internalType": "address", "name": "presale", "type": "address"}
                            ],
                            "name": "TokenPresaleLinked",
                            "type": "event"
                        }
                    ];

                    // 基础的预售ABI
                    this.presaleABI = [
                        {"inputs": [], "name": "hardcap", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "maxBuyPerWallet", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "startTime", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "getLGEConfig", "outputs": [
                            {"internalType": "uint256", "name": "vestingDelay_", "type": "uint256"},
                            {"internalType": "uint256", "name": "vestingRate_", "type": "uint256"},
                            {"internalType": "bool", "name": "vestingEnabled_", "type": "bool"},
                            {"internalType": "uint256", "name": "backingShare_", "type": "uint256"},
                            {"internalType": "address", "name": "backingReceiver_", "type": "address"},
                            {"internalType": "uint256", "name": "startTime_", "type": "uint256"},
                            {"internalType": "uint256", "name": "hardcap_", "type": "uint256"},
                            {"internalType": "uint256", "name": "maxBuyPerWallet_", "type": "uint256"}
                        ], "stateMutability": "view", "type": "function"}
                    ];

                    // 基础的代币ABI
                    this.tokenABI = [
                        {"inputs": [], "name": "name", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "totalSupply", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
                        {"inputs": [], "name": "pairTRX", "outputs": [{"internalType": "address", "name": "", "type": "address"}], "stateMutability": "view", "type": "function"}
                    ];

                    logToConsole('success', '[ABI] 基础ABI加载成功');

                } catch (error) {
                    logToConsole('error', `[ABI] ABI加载失败: ${error.message}`);
                    throw error;
                }
            }

            async start() {
                if (this.isRunning) {
                    logToConsole('warning', '[启动] 监听器已在运行');
                    return;
                }

                try {
                    this.isRunning = true;
                    logToConsole('info', '[启动] 开始监听事件...');

                    // 尝试事件监听
                    let eventListenersSet = 0;

                    // 监听TokenPresalePairCreated事件
                    if (await this.listenToEvent('TokenPresalePairCreated')) {
                        eventListenersSet++;
                    }

                    // 监听OwnershipTransferred事件
                    if (await this.listenToEvent('OwnershipTransferred')) {
                        eventListenersSet++;
                    }

                    // 监听TokenPresaleLinked事件
                    if (await this.listenToEvent('TokenPresaleLinked')) {
                        eventListenersSet++;
                    }

                    // 监听LGEConfigSet事件
                    if (await this.listenToEvent('LGEConfigSet')) {
                        eventListenersSet++;
                    }

                    // 监听VestingConfigSet事件
                    if (await this.listenToEvent('VestingConfigSet')) {
                        eventListenersSet++;
                    }

                    // 监听BackingConfigSet事件
                    if (await this.listenToEvent('BackingConfigSet')) {
                        eventListenersSet++;
                    }

                    if (eventListenersSet === 0) {
                        logToConsole('warning', '[启动] 事件监听设置失败，启用轮询模式');
                        this.startPolling();
                    } else {
                        logToConsole('success', `[启动] 事件监听已启动 (${eventListenersSet}/6 个监听器)`);
                    }

                } catch (error) {
                    logToConsole('error', `[启动] 失败: ${error.message}`);
                    this.errorCount++;
                    this.isRunning = false;
                    throw error;
                }
            }

            async listenToEvent(eventName) {
                try {
                    logToConsole('info', `[事件] 尝试设置 ${eventName} 监听...`);

                    // 方法1: 使用 TronWeb.trx.getEventResult 轮询方式
                    try {
                        if (this.tronWeb.trx && this.tronWeb.trx.getEventResult) {
                            logToConsole('info', `[事件] 使用 TronWeb.trx.getEventResult 方法监听 ${eventName}`);

                            // 记录上次检查的时间戳，避免重复处理
                            let lastCheckTime = Date.now();

                            // 启动轮询监听
                            const pollInterval = setInterval(async () => {
                                try {
                                    const events = await this.tronWeb.trx.getEventResult(this.coordinatorAddress, {
                                        eventName: eventName,
                                        size: 20,
                                        onlyConfirmed: false,
                                        sinceTimestamp: lastCheckTime
                                    });

                                    if (events && events.length > 0) {
                                        logToConsole('info', `[事件] 获取到 ${events.length} 个 ${eventName} 事件`);

                                        // 过滤出新事件（避免重复处理）
                                        const newEvents = events.filter(event => {
                                            const eventTime = event.timestamp || event.block_timestamp || Date.now();
                                            return eventTime > lastCheckTime;
                                        });

                                        if (newEvents.length > 0) {
                                            logToConsole('success', `[事件] 发现 ${newEvents.length} 个新的 ${eventName} 事件`);
                                            newEvents.forEach(event => {
                                                this.handleEvent(eventName, event);
                                            });
                                        } else {
                                            logToConsole('info', `[事件] 没有新的 ${eventName} 事件`);
                                        }

                                        lastCheckTime = Date.now();
                                    } else {
                                        logToConsole('info', `[事件] 未获取到 ${eventName} 事件`);
                                    }
                                } catch (pollError) {
                                    logToConsole('warning', `[事件] 轮询 ${eventName} 错误: ${pollError.message}`);
                                }
                            }, 3000); // 每3秒轮询一次

                            this.eventListeners.push({ interval: pollInterval, eventName });
                            logToConsole('success', `[事件] 使用 trx.getEventResult 轮询方式监听 ${eventName}`);
                            return true;
                        }
                    } catch (pollError) {
                        logToConsole('warning', `[事件] trx.getEventResult方法失败: ${pollError.message}`);
                    }

                    // 方法1.1: 尝试直接使用 TronWeb.getEventResult
                    try {
                        if (this.tronWeb.getEventResult) {
                            logToConsole('info', `[事件] 使用 TronWeb.getEventResult 方法监听 ${eventName}`);

                            let lastCheckTime = Date.now();

                            const pollInterval = setInterval(async () => {
                                try {
                                    const events = await this.tronWeb.getEventResult(this.coordinatorAddress, {
                                        eventName: eventName,
                                        size: 20,
                                        onlyConfirmed: false
                                    });

                                    if (events && events.length > 0) {
                                        logToConsole('info', `[事件] 获取到 ${events.length} 个 ${eventName} 事件`);
                                        events.forEach(event => {
                                            this.handleEvent(eventName, event);
                                        });
                                    }
                                } catch (pollError) {
                                    logToConsole('warning', `[事件] 轮询 ${eventName} 错误: ${pollError.message}`);
                                }
                            }, 3000);

                            this.eventListeners.push({ interval: pollInterval, eventName });
                            logToConsole('success', `[事件] 使用 getEventResult 轮询方式监听 ${eventName}`);
                            return true;
                        }
                    } catch (pollError) {
                        logToConsole('warning', `[事件] getEventResult方法失败: ${pollError.message}`);
                    }

                    // 方法2: 使用 TronWeb.getEventByTransactionID (需要交易ID)
                    try {
                        if (this.tronWeb.getEventByTransactionID) {
                            logToConsole('info', `[事件] TronWeb.getEventByTransactionID 方法可用`);
                            // 这个方法需要具体的交易ID，暂时跳过
                        }
                    } catch (error) {
                        logToConsole('warning', `[事件] getEventByTransactionID方法测试失败: ${error.message}`);
                    }

                    // 方法3: 使用 contract.getPastEvents (如果支持)
                    try {
                        if (this.contract.getPastEvents) {
                            logToConsole('info', `[事件] 尝试使用 getPastEvents 方法`);

                            const pastEvents = await this.contract.getPastEvents(eventName, {
                                fromBlock: 'latest',
                                toBlock: 'latest'
                            });

                            logToConsole('success', `[事件] getPastEvents 方法可用，获取到 ${pastEvents.length} 个历史事件`);

                            // 启动定期检查
                            const checkInterval = setInterval(async () => {
                                try {
                                    const newEvents = await this.contract.getPastEvents(eventName, {
                                        fromBlock: 'latest',
                                        toBlock: 'latest'
                                    });

                                    newEvents.forEach(event => {
                                        this.handleEvent(eventName, event);
                                    });
                                } catch (checkError) {
                                    logToConsole('warning', `[事件] 检查 ${eventName} 新事件错误: ${checkError.message}`);
                                }
                            }, 3000);

                            this.eventListeners.push({ interval: checkInterval, eventName });
                            logToConsole('success', `[事件] 使用 getPastEvents 监听 ${eventName}`);
                            return true;
                        }
                    } catch (pastEventsError) {
                        logToConsole('warning', `[事件] getPastEvents方法失败: ${pastEventsError.message}`);
                    }

                    // 方法4: 使用区块轮询检测事件
                    try {
                        logToConsole('info', `[事件] 使用区块轮询方式监听 ${eventName}`);

                        let lastBlockNumber = 0;

                        // 获取当前区块号
                        try {
                            const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                            lastBlockNumber = currentBlock.block_header.raw_data.number;
                            logToConsole('info', `[事件] 开始从区块 ${lastBlockNumber} 监听`);
                        } catch (blockError) {
                            logToConsole('warning', `[事件] 获取当前区块失败: ${blockError.message}`);
                        }

                        const blockPollInterval = setInterval(async () => {
                            try {
                                const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                                const currentBlockNumber = currentBlock.block_header.raw_data.number;

                                if (currentBlockNumber > lastBlockNumber) {
                                    // 检查新区块中的事件
                                    for (let blockNum = lastBlockNumber + 1; blockNum <= currentBlockNumber; blockNum++) {
                                        try {
                                            const block = await this.tronWeb.trx.getBlock(blockNum);
                                            if (block && block.transactions) {
                                                // 检查区块中的交易是否与我们的合约相关
                                                block.transactions.forEach(async (tx) => {
                                                    if (tx.raw_data && tx.raw_data.contract) {
                                                        tx.raw_data.contract.forEach(async (contract) => {
                                                            if (contract.parameter && contract.parameter.value) {
                                                                const contractAddress = this.tronWeb.address.fromHex(contract.parameter.value.contract_address);
                                                                if (contractAddress === this.coordinatorAddress) {
                                                                    // 这是我们关心的合约交易，尝试获取事件
                                                                    try {
                                                                        const txEvents = await this.tronWeb.getEventByTransactionID(tx.txID);
                                                                        if (txEvents && txEvents.length > 0) {
                                                                            txEvents.forEach(event => {
                                                                                if (event.event === eventName) {
                                                                                    this.handleEvent(eventName, event);
                                                                                }
                                                                            });
                                                                        }
                                                                    } catch (eventError) {
                                                                        // 忽略单个交易的事件获取错误
                                                                    }
                                                                }
                                                            }
                                                        });
                                                    }
                                                });
                                            }
                                        } catch (blockError) {
                                            // 忽略单个区块的错误
                                        }
                                    }
                                    lastBlockNumber = currentBlockNumber;
                                }
                            } catch (pollError) {
                                logToConsole('warning', `[事件] 区块轮询错误: ${pollError.message}`);
                            }
                        }, 5000); // 每5秒检查一次新区块

                        this.eventListeners.push({ interval: blockPollInterval, eventName, type: 'block' });
                        logToConsole('success', `[事件] 使用区块轮询方式监听 ${eventName}`);
                        return true;

                    } catch (blockError) {
                        logToConsole('warning', `[事件] 区块轮询方式失败: ${blockError.message}`);
                    }

                    // 方法5: 使用原生 TronWeb 事件监听 (如果支持)
                    try {
                        // 检查 TronWeb 是否有事件相关的API
                        logToConsole('info', `[事件] 检查 TronWeb 事件API...`);
                        logToConsole('info', `[事件] TronWeb.event 存在: ${!!this.tronWeb.event}`);
                        logToConsole('info', `[事件] TronWeb.getEventResult 存在: ${!!this.tronWeb.getEventResult}`);
                        logToConsole('info', `[事件] TronWeb.getEventByTransactionID 存在: ${!!this.tronWeb.getEventByTransactionID}`);

                        // 尝试使用 TronWeb 的事件监听
                        if (this.tronWeb.event && this.tronWeb.event.watch) {
                            const watcher = this.tronWeb.event.watch(this.coordinatorAddress, {
                                eventName: eventName,
                                onlyConfirmed: false
                            }, (error, result) => {
                                if (error) {
                                    logToConsole('error', `[事件] ${eventName} 监听错误: ${error.message}`);
                                    this.errorCount++;
                                } else if (result) {
                                    this.handleEvent(eventName, result);
                                }
                            });

                            this.eventListeners.push(watcher);
                            logToConsole('success', `[事件] 使用 TronWeb.event.watch 监听 ${eventName}`);
                            return true;
                        }
                    } catch (nativeError) {
                        logToConsole('warning', `[事件] 原生事件监听失败: ${nativeError.message}`);
                    }

                    // 如果所有方法都失败了
                    logToConsole('error', `[事件] 无法设置 ${eventName} 监听，所有方法都失败了`);
                    return false;

                } catch (error) {
                    logToConsole('error', `[事件] 设置 ${eventName} 监听失败: ${error.message}`);
                    this.errorCount++;
                    return false;
                }
            }

            startPolling() {
                logToConsole('info', '[轮询] 启动区块轮询模式...');

                this.pollingInterval = setInterval(async () => {
                    try {
                        const currentBlock = await this.tronWeb.trx.getCurrentBlock();
                        const currentBlockNumber = currentBlock.block_header.raw_data.number;

                        if (this.lastBlockNumber === 0) {
                            this.lastBlockNumber = currentBlockNumber;
                            logToConsole('info', `[轮询] 开始从区块 ${currentBlockNumber} 监听`);
                            return;
                        }

                        if (currentBlockNumber > this.lastBlockNumber) {
                            logToConsole('info', `[轮询] 检查新区块 ${this.lastBlockNumber + 1} 到 ${currentBlockNumber}`);

                            // 检查新区块中的事件
                            for (let blockNum = this.lastBlockNumber + 1; blockNum <= currentBlockNumber; blockNum++) {
                                await this.checkBlockForEvents(blockNum);
                            }

                            this.lastBlockNumber = currentBlockNumber;
                        }

                    } catch (error) {
                        logToConsole('error', `[轮询] 轮询错误: ${error.message}`);
                        this.errorCount++;
                    }
                }, 3000); // 每3秒检查一次
            }

            async checkBlockForEvents(blockNumber) {
                try {
                    // 这里可以实现具体的区块事件检查逻辑
                    // 由于TronWeb的限制，我们主要用于演示轮询机制
                    logToConsole('info', `[轮询] 检查区块 ${blockNumber} 中的事件...`);

                } catch (error) {
                    logToConsole('error', `[轮询] 检查区块 ${blockNumber} 失败: ${error.message}`);
                }
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                    logToConsole('info', '[轮询] 区块轮询已停止');
                }
            }

            async handleEvent(eventName, eventData) {
                try {
                    this.eventCount++;

                    const timestamp = new Date().toLocaleTimeString();
                    const contractAddr = this.coordinatorAddress.slice(0, 8) + '...';

                    // 创建事件分组
                    this.createEventGroup(eventName, timestamp, contractAddr);

                    logToConsole('event', `🎯 ${eventName} 事件触发`, '事件');

                    // 详细调试：显示完整的事件数据结构
                    logToConsole('debug', `事件数据结构: ${JSON.stringify(eventData, null, 2)}`, '调试');

                    // 尝试多种可能的事件数据格式
                    let eventParams = null;
                    let blockNumber = null;
                    let transactionId = null;

                    // 格式1: eventData.result
                    if (eventData.result) {
                        eventParams = eventData.result;
                        blockNumber = eventData.block;
                        transactionId = eventData.transaction;
                    }
                    // 格式2: eventData直接包含参数
                    else if (eventData.returnValues || eventData.args) {
                        eventParams = eventData.returnValues || eventData.args;
                        blockNumber = eventData.blockNumber;
                        transactionId = eventData.transactionHash;
                    }
                    // 格式3: TronWeb特定格式
                    else if (eventData.event) {
                        eventParams = eventData.result || eventData.parameters;
                        blockNumber = eventData.block_number;
                        transactionId = eventData.transaction_id;
                    }
                    // 格式4: 直接参数
                    else {
                        eventParams = eventData;
                    }

                    logToConsole('info', `[解析] 事件参数: ${JSON.stringify(eventParams, null, 2)}`);
                    logToConsole('info', `[解析] 区块号: ${blockNumber}, 交易ID: ${transactionId}`);

                    // 根据事件类型进行专门处理
                    switch (eventName) {
                        case 'TokenPresalePairCreated':
                            await this.handleTokenPresalePairCreated(eventParams, blockNumber, transactionId);
                            break;
                        case 'OwnershipTransferred':
                            await this.handleOwnershipTransferred(eventParams, blockNumber, transactionId);
                            break;
                        case 'TokenPresaleLinked':
                            await this.handleTokenPresaleLinked(eventParams, blockNumber, transactionId);
                            break;
                        case 'LGEConfigSet':
                            await this.handleLGEConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        case 'VestingConfigSet':
                            await this.handleVestingConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        case 'BackingConfigSet':
                            await this.handleBackingConfigSet(eventParams, blockNumber, transactionId);
                            break;
                        default:
                            await this.handleGenericEvent(eventName, eventParams, blockNumber, transactionId);
                    }

                    // 更新UI
                    document.getElementById('eventCount').textContent = this.eventCount;

                } catch (error) {
                    logToConsole('error', `[处理] 处理事件失败: ${error.message}`);
                    logToConsole('error', `[处理] 错误堆栈: ${error.stack}`);
                    this.errorCount++;
                }
            }

            createEventGroup(eventName, timestamp, contractAddr) {
                try {
                    const logContainer = document.getElementById('logContainer');
                    if (!logContainer) return;

                    const eventGroup = document.createElement('div');
                    eventGroup.className = 'event-group';
                    eventGroup.setAttribute('data-type', 'event');

                    const eventHeader = document.createElement('div');
                    eventHeader.className = 'event-header';
                    eventHeader.innerHTML = `
                        <span style="font-size: 14px;">🎯 ${eventName}</span>
                        <span style="float: right; font-size: 12px; opacity: 0.7;">${timestamp} | ${contractAddr}</span>
                    `;

                    const eventDetails = document.createElement('div');
                    eventDetails.className = 'event-details';
                    eventDetails.id = `event-details-${this.eventCount}`;

                    eventGroup.appendChild(eventHeader);
                    eventGroup.appendChild(eventDetails);
                    logContainer.appendChild(eventGroup);

                    // 自动滚动
                    const consoleOutput = document.getElementById('consoleOutput');
                    if (consoleOutput) {
                        consoleOutput.scrollTop = consoleOutput.scrollHeight;
                    }

                } catch (error) {
                    console.error('创建事件分组失败:', error);
                }
            }

            logEventDetail(message, type = 'info') {
                try {
                    const eventDetailsContainer = document.getElementById(`event-details-${this.eventCount}`);
                    if (!eventDetailsContainer) {
                        logToConsole(type, message, '事件详情');
                        return;
                    }

                    const detailEntry = document.createElement('div');
                    detailEntry.className = `log-entry log-${type}`;
                    detailEntry.style.margin = '2px 0';
                    detailEntry.style.padding = '4px 8px';
                    detailEntry.style.fontSize = '12px';

                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    detailEntry.appendChild(messageSpan);

                    eventDetailsContainer.appendChild(detailEntry);

                } catch (error) {
                    console.error('记录事件详情失败:', error);
                    logToConsole(type, message, '事件详情');
                }
            }

            async handleTokenPresalePairCreated(eventParams, blockNumber, transactionId) {
                try {
                    this.logEventDetail('🚀 检测到新的代币预售配对创建事件！', 'success');

                    // 解析事件参数
                    let tokenAddress = null;
                    let presaleAddress = null;

                    if (eventParams) {
                        // 尝试多种参数格式
                        tokenAddress = eventParams.token || eventParams.tokenAddress || eventParams[0];
                        presaleAddress = eventParams.presale || eventParams.presaleAddress || eventParams[1];

                        if (tokenAddress && typeof tokenAddress === 'object' && tokenAddress._hex) {
                            tokenAddress = this.tronWeb.address.fromHex(tokenAddress._hex);
                        }
                        if (presaleAddress && typeof presaleAddress === 'object' && presaleAddress._hex) {
                            presaleAddress = this.tronWeb.address.fromHex(presaleAddress._hex);
                        }
                    }

                    this.logEventDetail(`📍 代币地址: ${tokenAddress}`, 'info');
                    this.logEventDetail(`📍 预售地址: ${presaleAddress}`, 'info');
                    this.logEventDetail(`📦 区块号: ${blockNumber}`, 'info');
                    this.logEventDetail(`🔗 交易ID: ${transactionId}`, 'info');

                    // 获取代币详细信息
                    if (tokenAddress) {
                        this.logEventDetail('正在获取代币详细信息...', 'info');
                        await this.getTokenDetails(tokenAddress);
                    }

                    // 获取预售详细信息
                    if (presaleAddress) {
                        this.logEventDetail('正在获取预售详细信息...', 'info');
                        await this.getPresaleDetails(presaleAddress);
                    }

                    // 展示完整的预售配置信息
                    this.logEventDetail('=== 预售配置信息汇总 ===', 'success');
                    await this.displayPresaleConfigSummary(tokenAddress, presaleAddress);

                } catch (error) {
                    this.logEventDetail(`处理失败: ${error.message}`, 'error');
                    logToConsole('error', `TokenPresalePairCreated 处理失败: ${error.message}`, '错误');
                }
            }

            async handleOwnershipTransferred(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('info', '👑 检测到所有权转移事件');

                    let previousOwner = null;
                    let newOwner = null;

                    if (eventParams) {
                        previousOwner = eventParams.previousOwner || eventParams[0];
                        newOwner = eventParams.newOwner || eventParams[1];

                        if (previousOwner && typeof previousOwner === 'object' && previousOwner._hex) {
                            previousOwner = this.tronWeb.address.fromHex(previousOwner._hex);
                        }
                        if (newOwner && typeof newOwner === 'object' && newOwner._hex) {
                            newOwner = this.tronWeb.address.fromHex(newOwner._hex);
                        }
                    }

                    logToConsole('info', `📍 原所有者: ${previousOwner}`);
                    logToConsole('info', `📍 新所有者: ${newOwner}`);
                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[OwnershipTransferred] 处理失败: ${error.message}`);
                }
            }

            async handleTokenPresaleLinked(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', '🔗 检测到代币预售链接事件！');

                    let tokenAddress = null;
                    let presaleAddress = null;

                    if (eventParams) {
                        tokenAddress = eventParams.token || eventParams.tokenAddress || eventParams[0];
                        presaleAddress = eventParams.presale || eventParams.presaleAddress || eventParams[1];

                        if (tokenAddress && typeof tokenAddress === 'object' && tokenAddress._hex) {
                            tokenAddress = this.tronWeb.address.fromHex(tokenAddress._hex);
                        }
                        if (presaleAddress && typeof presaleAddress === 'object' && presaleAddress._hex) {
                            presaleAddress = this.tronWeb.address.fromHex(presaleAddress._hex);
                        }
                    }

                    logToConsole('info', `📍 代币地址: ${tokenAddress}`);
                    logToConsole('info', `📍 预售地址: ${presaleAddress}`);
                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                    // 获取代币详细信息
                    if (tokenAddress) {
                        await this.getTokenDetails(tokenAddress);
                    }

                    // 获取预售详细信息
                    if (presaleAddress) {
                        await this.getPresaleDetails(presaleAddress);
                    }

                } catch (error) {
                    logToConsole('error', `[TokenPresaleLinked] 处理失败: ${error.message}`);
                }
            }

            async handleGenericEvent(eventName, eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('info', `📋 通用事件处理: ${eventName}`);

                    if (eventParams) {
                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // 跳过数字索引

                            let displayValue = value;
                            if (typeof value === 'string' && value.length > 42) {
                                displayValue = value.slice(0, 8) + '...' + value.slice(-4);
                            }

                            logToConsole('info', `  ▸ ${key}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[GenericEvent] 处理失败: ${error.message}`);
                }
            }

            async getTokenDetails(tokenAddress) {
                try {
                    this.logEventDetail('=== 第二组 - 代币基础信息 ===', 'success');
                    this.logEventDetail(`🪙 获取代币详细信息: ${tokenAddress}`, 'info');

                    // 使用加载的完整tokenABI或基础ABI
                    const tokenABI = this.tokenABI || [
                        {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"pairTRX","outputs":[{"name":"","type":"address"}],"type":"function"},
                        {"constant":true,"inputs":[],"name":"baseConfig","outputs":[
                            {"name":"feeBuy","type":"uint256"},
                            {"name":"feeSell","type":"uint256"},
                            {"name":"lpBurnEnabled","type":"bool"},
                            {"name":"lpBurnFrequency","type":"uint256"},
                            {"name":"percentForLPBurn","type":"uint256"},
                            {"name":"burnLimit","type":"uint256"},
                            {"name":"protectTime","type":"uint256"},
                            {"name":"protectFee","type":"uint256"},
                            {"name":"isInsideSell","type":"bool"},
                            {"name":"swapThreshold","type":"uint256"}
                        ],"type":"function"}
                    ];

                    const tokenContract = await this.tronWeb.contract(tokenABI, tokenAddress);

                    // 获取代币名称
                    try {
                        const name = await tokenContract.name().call();
                        this.logEventDetail(`📛 Token name（代币名称）: ${name}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`📛 Token name（代币名称）: 获取失败`, 'warning');
                    }

                    // 获取代币符号
                    try {
                        const symbol = await tokenContract.symbol().call();
                        this.logEventDetail(`🏷️ Name(Symbol)（代币符号）: ${symbol}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`🏷️ Name(Symbol)（代币符号）: 获取失败`, 'warning');
                    }

                    // 获取总供应量
                    try {
                        const totalSupply = await tokenContract.totalSupply().call();
                        let decimals = 18; // 默认值

                        // 尝试获取小数位数
                        try {
                            const decimalResult = await tokenContract.decimals().call();
                            decimals = typeof decimalResult === 'bigint' ? Number(decimalResult) : parseInt(decimalResult);
                        } catch (e) {
                            // 使用默认值
                        }

                        let formattedSupply;
                        if (typeof totalSupply === 'bigint') {
                            const divisor = BigInt(10) ** BigInt(decimals);
                            const supplyInTokens = totalSupply / divisor;
                            formattedSupply = supplyInTokens.toLocaleString();
                        } else {
                            const supplyNum = parseFloat(totalSupply);
                            formattedSupply = (supplyNum / Math.pow(10, decimals)).toLocaleString();
                        }
                        this.logEventDetail(`💰 Supply（总供应量）: ${formattedSupply}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`💰 Supply（总供应量）: 获取失败`, 'warning');
                    }

                    // 获取代币经济学预设
                    try {
                        const baseConfig = await tokenContract.baseConfig().call();
                        this.logEventDetail(`⚙️ Tokenomic preset（代币经济学预设）:`, 'success');
                        this.logEventDetail(`  - 买入手续费: ${baseConfig.feeBuy || baseConfig[0]}%`, 'info');
                        this.logEventDetail(`  - 卖出手续费: ${baseConfig.feeSell || baseConfig[1]}%`, 'info');
                        this.logEventDetail(`  - LP燃烧启用: ${(baseConfig.lpBurnEnabled || baseConfig[2]) ? '是' : '否'}`, 'info');
                        this.logEventDetail(`  - LP燃烧频率: ${baseConfig.lpBurnFrequency || baseConfig[3]}`, 'info');
                        this.logEventDetail(`  - LP燃烧比例: ${baseConfig.percentForLPBurn || baseConfig[4]}%`, 'info');
                    } catch (e) {
                        this.logEventDetail(`⚙️ Tokenomic preset（代币经济学预设）: 获取失败`, 'warning');
                    }

                } catch (error) {
                    this.logEventDetail(`[代币信息] 获取失败: ${error.message}`, 'error');
                }
            }

            async getPresaleDetails(presaleAddress) {
                try {
                    this.logEventDetail('=== 第一组 - 预售配置信息 ===', 'success');
                    this.logEventDetail(`🚀 获取预售详细信息: ${presaleAddress}`, 'info');

                    // 使用加载的完整presaleABI或基础ABI
                    const presaleABI = this.presaleABI || [
                        {"inputs":[],"name":"hardcap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"maxBuyPerWallet","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"presaleEthAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"tradeEthAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"maxTotalNum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"presaleMaxNum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"getLGEConfig","outputs":[
                            {"internalType":"uint256","name":"vestingDelay_","type":"uint256"},
                            {"internalType":"uint256","name":"vestingRate_","type":"uint256"},
                            {"internalType":"bool","name":"vestingEnabled_","type":"bool"},
                            {"internalType":"uint256","name":"backingShare_","type":"uint256"},
                            {"internalType":"address","name":"backingReceiver_","type":"address"},
                            {"internalType":"uint256","name":"startTime_","type":"uint256"},
                            {"internalType":"uint256","name":"hardcap_","type":"uint256"},
                            {"internalType":"uint256","name":"maxBuyPerWallet_","type":"uint256"}
                        ],"stateMutability":"view","type":"function"}
                    ];

                    const presaleContract = await this.tronWeb.contract(presaleABI, presaleAddress);

                    // 获取Token for LGE（通过事件已获取）
                    this.logEventDetail(`🪙 Token for LGE（流动性生成事件代币）: 预售合约地址`, 'success');
                    this.logEventDetail(`📍 预售合约地址: ${presaleAddress}`, 'info');

                    // 获取TST/TRX汇率
                    try {
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();
                        const tradeEthAmount = await presaleContract.tradeEthAmount().call();

                        const presaleAmount = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) : parseInt(presaleEthAmount);
                        const tradeAmount = typeof tradeEthAmount === 'bigint' ? Number(tradeEthAmount) : parseInt(tradeEthAmount);

                        const rate = presaleAmount / tradeAmount;
                        this.logEventDetail(`💱 TST/TRX 汇率: 1 TRX = ${rate.toFixed(4)} TST`, 'success');
                    } catch (e) {
                        this.logEventDetail(`� TST/TRX 汇率: 获取失败`, 'warning');
                    }

                    // 获取Soft cap（需要计算或查找）
                    try {
                        const maxTotalNum = await presaleContract.maxTotalNum().call();
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();

                        const maxTotal = typeof maxTotalNum === 'bigint' ? Number(maxTotalNum) : parseInt(maxTotalNum);
                        const ethAmount = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) : parseInt(presaleEthAmount);

                        const softCap = (maxTotal * ethAmount) / 1e6; // 转换为TRX
                        this.logEventDetail(`🎯 Soft cap（软顶）: ${softCap.toLocaleString()} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`🎯 Soft cap（软顶）: 计算失败`, 'warning');
                    }

                    // 获取Hard cap
                    try {
                        const hardcap = await presaleContract.hardcap().call();
                        const hardcapTRX = typeof hardcap === 'bigint' ? Number(hardcap) / 1e6 : parseInt(hardcap) / 1e6;
                        this.logEventDetail(`🎯 Hard cap（硬顶）: ${hardcapTRX.toLocaleString()} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`🎯 Hard cap（硬顶）: 获取失败`, 'warning');
                    }

                    // 获取Min buy（通常是presaleEthAmount）
                    try {
                        const presaleEthAmount = await presaleContract.presaleEthAmount().call();
                        const minBuy = typeof presaleEthAmount === 'bigint' ? Number(presaleEthAmount) / 1e6 : parseInt(presaleEthAmount) / 1e6;
                        this.logEventDetail(`💰 Min buy（最小购买量）: ${minBuy} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`💰 Min buy（最小购买量）: 获取失败`, 'warning');
                    }

                    // 获取Max buy
                    try {
                        const maxBuyPerWallet = await presaleContract.maxBuyPerWallet().call();
                        const maxBuy = typeof maxBuyPerWallet === 'bigint' ? Number(maxBuyPerWallet) / 1e6 : parseInt(maxBuyPerWallet) / 1e6;
                        this.logEventDetail(`💰 Max buy（最大购买量）: ${maxBuy} TRX`, 'success');
                    } catch (e) {
                        this.logEventDetail(`💰 Max buy（最大购买量）: 获取失败`, 'warning');
                    }

                    // 获取Start time
                    try {
                        const startTime = await presaleContract.startTime().call();
                        const timestamp = typeof startTime === 'bigint' ? Number(startTime) : parseInt(startTime);
                        const startDate = new Date(timestamp * 1000);
                        this.logEventDetail(`⏰ Start time（开始时间）: ${startDate.toLocaleString()}`, 'success');
                    } catch (e) {
                        this.logEventDetail(`⏰ Start time（开始时间）: 获取失败`, 'warning');
                    }

                    // 获取LGE配置信息
                    try {
                        const lgeConfig = await presaleContract.getLGEConfig().call();

                        // Vesting delay
                        const vestingDelay = typeof lgeConfig.vestingDelay_ === 'bigint' ? Number(lgeConfig.vestingDelay_) : parseInt(lgeConfig.vestingDelay_ || lgeConfig[0]);
                        this.logEventDetail(`⏳ Vesting delay（释放延迟）: ${vestingDelay} 天`, 'success');

                        // Vesting rate
                        const vestingRate = typeof lgeConfig.vestingRate_ === 'bigint' ? Number(lgeConfig.vestingRate_) : parseInt(lgeConfig.vestingRate_ || lgeConfig[1]);
                        this.logEventDetail(`📊 Vesting rate(%)（释放比例）: ${vestingRate}%`, 'success');

                        // Vesting enabled
                        const vestingEnabled = lgeConfig.vestingEnabled_ || lgeConfig[2];
                        this.logEventDetail(`🔄 Vesting rounds（释放轮次）: ${vestingEnabled ? '启用' : '禁用'}`, 'success');

                        // Backing
                        const backingShare = typeof lgeConfig.backingShare_ === 'bigint' ? Number(lgeConfig.backingShare_) : parseInt(lgeConfig.backingShare_ || lgeConfig[3]);
                        let backingReceiver = lgeConfig.backingReceiver_ || lgeConfig[4];

                        // 确保地址是Base58格式
                        if (backingReceiver && typeof backingReceiver === 'string' && backingReceiver.startsWith('0x')) {
                            try {
                                backingReceiver = this.tronWeb.address.fromHex(backingReceiver);
                            } catch (e) {
                                // 如果转换失败，保持原格式
                            }
                        }

                        this.logEventDetail(`🏦 Backing（背书/支持）: ${backingShare}% -> ${backingReceiver}`, 'success');

                    } catch (e) {
                        this.logEventDetail(`⚙️ LGE配置信息: 获取失败 - ${e.message}`, 'warning');
                    }

                } catch (error) {
                    this.logEventDetail(`[预售信息] 获取失败: ${error.message}`, 'error');
                }
            }

            async displayPresaleConfigSummary(tokenAddress, presaleAddress) {
                try {
                    this.logEventDetail('=== 补充信息获取 ===', 'info');

                    // 获取TRX交易对信息
                    if (tokenAddress) {
                        try {
                            const tokenContract = await this.tronWeb.contract(this.tokenABI, tokenAddress);
                            const pairTRX = await tokenContract.pairTRX().call();
                            this.logEventDetail(`🔗 TRX pair（TRX交易对）: ${pairTRX}`, 'success');
                        } catch (e) {
                            this.logEventDetail(`🔗 TRX pair（TRX交易对）: 获取失败`, 'warning');
                        }
                    }

                    // 计算End time和Duration
                    if (presaleAddress) {
                        try {
                            const presaleContract = await this.tronWeb.contract(this.presaleABI, presaleAddress);
                            const startTime = await presaleContract.startTime().call();
                            const startTimestamp = typeof startTime === 'bigint' ? Number(startTime) : parseInt(startTime);

                            // 假设预售持续时间为7天（可以根据实际合约调整）
                            const durationDays = 7;
                            const endTimestamp = startTimestamp + (durationDays * 24 * 60 * 60);
                            const endDate = new Date(endTimestamp * 1000);

                            this.logEventDetail(`⏰ End time（结束时间）: ${endDate.toLocaleString()}`, 'success');
                            this.logEventDetail(`⏱️ Duration（持续时间）: ${durationDays} 天`, 'success');
                        } catch (e) {
                            this.logEventDetail(`⏰ End time（结束时间）: 计算失败`, 'warning');
                            this.logEventDetail(`⏱️ Duration（持续时间）: 计算失败`, 'warning');
                        }
                    }

                    this.logEventDetail('=== 预售配置信息获取完成 ===', 'success');

                } catch (error) {
                    this.logEventDetail(`[补充信息] 获取失败: ${error.message}`, 'error');
                }
            }

            stop() {
                this.isRunning = false;

                // 清理所有事件监听器
                this.eventListeners.forEach((listener, index) => {
                    try {
                        if (listener.interval) {
                            // 清理轮询间隔
                            clearInterval(listener.interval);
                            const eventName = listener.eventName || '未知';
                            const type = listener.type || '轮询';
                            logToConsole('info', `[停止] 已停止 ${eventName} ${type}监听`);
                        } else if (listener.stop && typeof listener.stop === 'function') {
                            // 清理原生监听器
                            listener.stop();
                            logToConsole('info', `[停止] 已停止原生事件监听器 #${index}`);
                        } else if (listener.unwatch && typeof listener.unwatch === 'function') {
                            // 清理watch类型监听器
                            listener.unwatch();
                            logToConsole('info', `[停止] 已停止watch事件监听器 #${index}`);
                        } else {
                            logToConsole('info', `[停止] 监听器 #${index} 类型未知，跳过清理`);
                        }
                    } catch (error) {
                        logToConsole('warning', `[停止] 清理监听器 #${index} 失败: ${error.message}`);
                    }
                });

                this.eventListeners = [];
                this.stopPolling();
                logToConsole('info', '[停止] 所有事件监听已停止');
            }

            async handleLGEConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', '⚙️ 检测到LGE配置设置事件！');

                    // 解析LGE配置参数
                    if (eventParams) {
                        // 根据合约定义，LGEConfigSet可能包含以下参数
                        const configKeys = [
                            'lgeAddress', 'lgeContract', 'address',
                            'duration', 'period', 'time',
                            'minContribution', 'maxContribution', 'contribution',
                            'rate', 'price', 'exchangeRate'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // 跳过数字索引

                            let displayValue = value;
                            let label = key;

                            // 格式化显示值
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRON地址
                                displayValue = value;
                                label = `📍 ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // 数字值
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('time') || key.toLowerCase().includes('duration')) {
                                    // 时间戳
                                    displayValue = new Date(Number(numValue) * 1000).toLocaleString();
                                    label = `⏰ ${key}`;
                                } else if (key.toLowerCase().includes('contribution') || key.toLowerCase().includes('amount')) {
                                    // 金额
                                    displayValue = (Number(numValue) / 1e6).toLocaleString() + ' TRX';
                                    label = `💰 ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `🔢 ${key}`;
                                }
                            } else {
                                label = `📋 ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[LGEConfigSet] 处理失败: ${error.message}`);
                }
            }

            async handleVestingConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', '🔒 检测到归属配置设置事件！');

                    // 解析归属配置参数
                    if (eventParams) {
                        const configKeys = [
                            'vestingContract', 'beneficiary', 'address',
                            'cliff', 'duration', 'period',
                            'amount', 'totalAmount', 'vestingAmount',
                            'startTime', 'cliffTime', 'endTime'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // 跳过数字索引

                            let displayValue = value;
                            let label = key;

                            // 格式化显示值
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRON地址
                                displayValue = value;
                                label = `📍 ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // 数字值
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('time') || key.toLowerCase().includes('cliff')) {
                                    // 时间戳
                                    displayValue = new Date(Number(numValue) * 1000).toLocaleString();
                                    label = `⏰ ${key}`;
                                } else if (key.toLowerCase().includes('amount')) {
                                    // 代币数量
                                    displayValue = (Number(numValue) / 1e18).toLocaleString() + ' 代币';
                                    label = `💰 ${key}`;
                                } else if (key.toLowerCase().includes('duration') || key.toLowerCase().includes('period')) {
                                    // 持续时间（秒）
                                    const days = Number(numValue) / (24 * 60 * 60);
                                    displayValue = `${days.toFixed(1)} 天`;
                                    label = `⏳ ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `🔢 ${key}`;
                                }
                            } else {
                                label = `📋 ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[VestingConfigSet] 处理失败: ${error.message}`);
                }
            }

            async handleBackingConfigSet(eventParams, blockNumber, transactionId) {
                try {
                    logToConsole('success', '🛡️ 检测到支持配置设置事件！');

                    // 解析支持配置参数
                    if (eventParams) {
                        const configKeys = [
                            'backingToken', 'collateralToken', 'token',
                            'backingRatio', 'collateralRatio', 'ratio',
                            'minBacking', 'maxBacking', 'backing',
                            'oracle', 'priceOracle', 'priceFeed'
                        ];

                        for (const [key, value] of Object.entries(eventParams)) {
                            if (!isNaN(key)) continue; // 跳过数字索引

                            let displayValue = value;
                            let label = key;

                            // 格式化显示值
                            if (typeof value === 'string' && value.length === 42 && value.startsWith('T')) {
                                // TRON地址
                                displayValue = value;
                                label = `📍 ${key}`;
                            } else if (typeof value === 'bigint' || (typeof value === 'string' && /^\d+$/.test(value))) {
                                // 数字值
                                const numValue = typeof value === 'bigint' ? value : BigInt(value);
                                if (key.toLowerCase().includes('ratio')) {
                                    // 比率（通常是百分比）
                                    displayValue = (Number(numValue) / 100).toFixed(2) + '%';
                                    label = `📊 ${key}`;
                                } else if (key.toLowerCase().includes('backing') || key.toLowerCase().includes('amount')) {
                                    // 支持金额
                                    displayValue = (Number(numValue) / 1e18).toLocaleString() + ' 代币';
                                    label = `💰 ${key}`;
                                } else {
                                    displayValue = numValue.toLocaleString();
                                    label = `🔢 ${key}`;
                                }
                            } else {
                                label = `📋 ${key}`;
                            }

                            logToConsole('info', `  ${label}: ${displayValue}`);
                        }
                    }

                    logToConsole('info', `📦 区块号: ${blockNumber}`);
                    logToConsole('info', `🔗 交易ID: ${transactionId}`);

                } catch (error) {
                    logToConsole('error', `[BackingConfigSet] 处理失败: ${error.message}`);
                }
            }

            // 测试方法：模拟事件数据
            async testEventHandling() {
                logToConsole('info', '[测试] 开始测试事件处理逻辑...');

                // 模拟 TokenPresalePairCreated 事件
                const mockTokenPresaleEvent = {
                    result: {
                        token: 'TNmNmMMVS8BmWgTem7HExyjru1bv21sKRC',
                        presale: 'TS6bcFFQuooYFmrufqd79qM6FSdEpY9gee'
                    },
                    block: 12345678,
                    transaction: 'abc123def456789'
                };

                logToConsole('info', '[测试] 模拟 TokenPresalePairCreated 事件...');
                await this.handleEvent('TokenPresalePairCreated', mockTokenPresaleEvent);

                // 模拟 OwnershipTransferred 事件
                const mockOwnershipEvent = {
                    result: {
                        previousOwner: 'TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH',
                        newOwner: 'TBy2vsVgN6XYi7uVL54vvWYEcueAUmAdEu'
                    },
                    block: 12345679,
                    transaction: 'def456ghi789abc'
                };

                logToConsole('info', '[测试] 模拟 OwnershipTransferred 事件...');
                await this.handleEvent('OwnershipTransferred', mockOwnershipEvent);

                // 模拟 LGEConfigSet 事件
                const mockLGEConfigEvent = {
                    result: {
                        lgeAddress: 'TLGEAddress123456789012345678901234567890',
                        duration: '2592000', // 30天
                        minContribution: '1000000', // 1 TRX
                        maxContribution: '10000000000' // 10,000 TRX
                    },
                    block: 12345680,
                    transaction: 'lge123config456'
                };

                logToConsole('info', '[测试] 模拟 LGEConfigSet 事件...');
                await this.handleEvent('LGEConfigSet', mockLGEConfigEvent);

                // 模拟 VestingConfigSet 事件
                const mockVestingConfigEvent = {
                    result: {
                        beneficiary: 'TBeneficiary123456789012345678901234567',
                        cliff: '7776000', // 90天
                        duration: '31536000', // 365天
                        amount: '1000000000000000000000' // 1000 代币
                    },
                    block: 12345681,
                    transaction: 'vest123config456'
                };

                logToConsole('info', '[测试] 模拟 VestingConfigSet 事件...');
                await this.handleEvent('VestingConfigSet', mockVestingConfigEvent);

                // 模拟 BackingConfigSet 事件
                const mockBackingConfigEvent = {
                    result: {
                        backingToken: 'TBackingToken123456789012345678901234',
                        backingRatio: '8000', // 80%
                        minBacking: '100000000000000000000', // 100 代币
                        oracle: 'TOracle123456789012345678901234567890'
                    },
                    block: 12345682,
                    transaction: 'back123config456'
                };

                logToConsole('info', '[测试] 模拟 BackingConfigSet 事件...');
                await this.handleEvent('BackingConfigSet', mockBackingConfigEvent);

                logToConsole('success', '[测试] 所有事件处理测试完成！');
            }

            // 手动检查最近的事件
            async checkRecentEvents() {
                try {
                    logToConsole('info', '[检查] 开始检查最近的事件...');

                    const eventNames = [
                        'TokenPresalePairCreated',
                        'OwnershipTransferred',
                        'TokenPresaleLinked',
                        'LGEConfigSet',
                        'VestingConfigSet',
                        'BackingConfigSet'
                    ];

                    for (const eventName of eventNames) {
                        try {
                            logToConsole('info', `[检查] 查询 ${eventName} 事件...`);

                            // 方法1: 使用 trx.getEventResult
                            if (this.tronWeb.trx && this.tronWeb.trx.getEventResult) {
                                const events = await this.tronWeb.trx.getEventResult(this.coordinatorAddress, {
                                    eventName: eventName,
                                    size: 5,
                                    onlyConfirmed: false
                                });

                                if (events && events.length > 0) {
                                    logToConsole('success', `[检查] 找到 ${events.length} 个 ${eventName} 事件`);
                                    events.forEach((event, index) => {
                                        logToConsole('info', `[检查] 事件 ${index + 1}: ${JSON.stringify(event, null, 2)}`);
                                    });
                                } else {
                                    logToConsole('info', `[检查] 未找到 ${eventName} 事件`);
                                }
                            }

                            // 方法2: 使用 getEventResult
                            else if (this.tronWeb.getEventResult) {
                                const events = await this.tronWeb.getEventResult(this.coordinatorAddress, {
                                    eventName: eventName,
                                    size: 5,
                                    onlyConfirmed: false
                                });

                                if (events && events.length > 0) {
                                    logToConsole('success', `[检查] 找到 ${events.length} 个 ${eventName} 事件`);
                                    events.forEach((event, index) => {
                                        logToConsole('info', `[检查] 事件 ${index + 1}: ${JSON.stringify(event, null, 2)}`);
                                    });
                                } else {
                                    logToConsole('info', `[检查] 未找到 ${eventName} 事件`);
                                }
                            }

                        } catch (eventError) {
                            logToConsole('warning', `[检查] 查询 ${eventName} 失败: ${eventError.message}`);
                        }
                    }

                    logToConsole('success', '[检查] 最近事件检查完成');

                } catch (error) {
                    logToConsole('error', `[检查] 检查最近事件失败: ${error.message}`);
                }
            }

            getStatus() {
                return {
                    isRunning: this.isRunning,
                    eventCount: this.eventCount,
                    errorCount: this.errorCount
                };
            }
        }

        // 页面初始化
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // 初始化日志过滤器
                initLogFilters();

                logToConsole('info', '页面加载完成', '页面');
                eventMonitor = new SimpleEventMonitor();
                window.eventMonitor = eventMonitor; // 暴露到全局供调试

                logToConsole('success', '事件监听器已初始化', '系统');
            } catch (error) {
                console.error('页面初始化失败:', error);
                logToConsole('error', `页面初始化失败: ${error.message}`, '系统');
            }
        });

        // 全局错误处理
        window.addEventListener('error', function(event) {
            logToConsole('error', `JavaScript错误: ${event.error?.message || event.message}`, '系统错误');
            console.error('全局错误:', event.error);
        });

        window.addEventListener('unhandledrejection', function(event) {
            logToConsole('error', `未处理的Promise拒绝: ${event.reason?.message || event.reason}`, '系统错误');
            console.error('未处理的Promise拒绝:', event.reason);
        });

        // 辅助函数：安全执行异步操作
        async function safeExecute(operation, operationName) {
            try {
                return await operation();
            } catch (error) {
                logToConsole('error', `${operationName}失败: ${error.message}`, '错误');
                console.error(`${operationName}失败:`, error);
                throw error;
            }
        }

        // 辅助函数：格式化地址显示
        function formatAddress(address) {
            if (!address || typeof address !== 'string') return '未知地址';
            if (address.length <= 10) return address;
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        // 辅助函数：格式化数字
        function formatNumber(num, decimals = 2) {
            if (typeof num === 'bigint') {
                return num.toLocaleString();
            }
            if (typeof num === 'string') {
                const parsed = parseFloat(num);
                return isNaN(parsed) ? num : parsed.toLocaleString(undefined, { maximumFractionDigits: decimals });
            }
            if (typeof num === 'number') {
                return num.toLocaleString(undefined, { maximumFractionDigits: decimals });
            }
            return String(num);
        }

        async function startMonitoring() {
            if (!eventMonitor) {
                logToConsole('error', '[错误] 事件监听器未创建');
                return;
            }

            try {
                document.getElementById('startBtn').disabled = true;
                document.getElementById('connectionStatus').textContent = '连接中...';

                logToConsole('info', '开始启动事件监听器...', '启动');

                await safeExecute(
                    () => eventMonitor.initialize(),
                    '初始化事件监听器'
                );

                await safeExecute(
                    () => eventMonitor.start(),
                    '启动事件监听'
                );

                document.getElementById('stopBtn').disabled = false;
                document.getElementById('connectionStatus').textContent = '已连接';

                startTime = Date.now();
                isMonitoring = true;

                // 启动运行时间计时器
                if (uptimeTimer) clearInterval(uptimeTimer);
                uptimeTimer = setInterval(updateUptime, 1000);

                logToConsole('success', '事件监听器启动成功！', '启动');

            } catch (error) {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('connectionStatus').textContent = '连接失败';
                logToConsole('error', `启动失败: ${error.message}`, '启动');
                isMonitoring = false;
            }
        }

        function stopMonitoring() {
            if (eventMonitor) {
                eventMonitor.stop();
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('connectionStatus').textContent = '已断开';
            
            isMonitoring = false;
            
            if (uptimeTimer) {
                clearInterval(uptimeTimer);
                uptimeTimer = null;
            }
        }

        async function testConnection() {
            logToConsole('info', '[测试] 开始连接测试...');
            
            try {
                if (typeof window.TronWeb === 'undefined') {
                    throw new Error('TronWeb库未加载');
                }

                const tronWeb = new window.TronWeb({
                    fullHost: 'https://nile.trongrid.io'
                });

                const currentBlock = await tronWeb.trx.getCurrentBlock();
                logToConsole('success', `[测试] 连接成功，当前区块: ${currentBlock.block_header.raw_data.number}`);
                
                // 测试合约地址
                const isValid = tronWeb.isAddress('TTMTNpZPeaxV9aT3mDuhMT7t6Suu1NtMrc');
                logToConsole('success', `[测试] 合约地址有效性: ${isValid}`);
                
            } catch (error) {
                logToConsole('error', `[测试] 连接测试失败: ${error.message}`);
            }
        }

        function clearConsole() {
            document.getElementById('consoleOutput').innerHTML = '';
            logToConsole('info', '[清空] 控制台已清空');
        }

        function updateUptime() {
            if (!startTime) return;
            
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / (1000 * 60 * 60));
            const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsed % (1000 * 60)) / 1000);
            
            const uptimeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('uptime').textContent = uptimeStr;
        }

        function logToConsole(type, message) {
            const consoleOutput = document.getElementById('consoleOutput');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // 更新错误计数
            if (type === 'error') {
                const errorCountEl = document.getElementById('errorCount');
                const currentCount = parseInt(errorCountEl.textContent) || 0;
                errorCountEl.textContent = currentCount + 1;
            }
            
            // 限制日志条数
            const logEntries = consoleOutput.querySelectorAll('.log-entry');
            if (logEntries.length > 200) {
                logEntries[0].remove();
            }
        }

        // 检查最新预售事件功能
        async function checkLatestPresaleEvents() {
            try {
                logToConsole('info', '📊 开始检查最新预售事件...', '检查');

                if (!eventMonitor) {
                    logToConsole('error', '事件监听器未初始化，请先启动监听', '检查');
                    return;
                }

                if (!eventMonitor.tronWeb) {
                    logToConsole('error', 'TronWeb未初始化，请先成功启动监听器', '检查');
                    return;
                }

                const contractAddress = eventMonitor.coordinatorAddress;
                logToConsole('info', `🔍 正在检查合约地址: ${contractAddress}`, '检查');

                try {
                    // 使用TronWeb的getEventResult方法获取最新事件
                    let events;

                    // 尝试不同的API调用方式
                    if (eventMonitor.tronWeb.getEventResult) {
                        events = await eventMonitor.tronWeb.getEventResult(contractAddress, {
                            eventName: 'TokenPresalePairCreated',
                            size: 5,
                            onlyConfirmed: true
                        });
                    } else if (eventMonitor.tronWeb.trx && eventMonitor.tronWeb.trx.getEventResult) {
                        events = await eventMonitor.tronWeb.trx.getEventResult(contractAddress, {
                            eventName: 'TokenPresalePairCreated',
                            size: 5,
                            onlyConfirmed: true
                        });
                    } else {
                        throw new Error('getEventResult方法不可用');
                    }

                    if (events && events.length > 0) {
                        logToConsole('success', `🎉 发现 ${events.length} 个TokenPresalePairCreated事件`, '检查');

                        // 处理最新的事件
                        for (let i = 0; i < Math.min(events.length, 2); i++) {
                            const event = events[i];
                            logToConsole('info', `📋 处理第 ${i + 1} 个事件...`, '检查');

                            // 调用事件处理函数
                            await eventMonitor.handleTokenPresalePairCreated(
                                event.result,
                                event.block_number,
                                event.transaction_id
                            );
                        }

                        logToConsole('success', '✅ 最新预售事件检查完成', '检查');
                    } else {
                        logToConsole('info', '📭 未发现TokenPresalePairCreated事件', '检查');
                        logToConsole('info', '💡 提示：可能该合约还没有创建预售配对，或者事件还未确认', '检查');
                    }

                } catch (eventError) {
                    logToConsole('warning', `获取事件失败: ${eventError.message}`, '检查');

                    // 尝试备用方法：检查合约是否存在
                    try {
                        const contractInfo = await eventMonitor.tronWeb.trx.getContract(contractAddress);
                        if (contractInfo && contractInfo.contract_address) {
                            logToConsole('success', `✅ 合约地址有效: ${contractInfo.contract_address}`, '检查');
                            logToConsole('info', '💡 合约存在但可能还没有TokenPresalePairCreated事件', '检查');
                        }
                    } catch (contractError) {
                        logToConsole('error', `合约地址验证失败: ${contractError.message}`, '检查');
                    }
                }

            } catch (error) {
                logToConsole('error', `检查失败: ${error.message}`, '检查');
            }
        }
    </script>
</body>
</html>
