// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./Interfaces.sol";
import "./Token.sol";

library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}


interface CCoin {
    function pairUSDT() external pure returns (address);
}

contract PRESALE is Ownable, ReentrancyGuard {
    using Address for address;
    //bsc测试网
    address public USDT = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684;
    IPancakeRouter02 router = IPancakeRouter02(0x87FD5305E6a40F378da124864B2D479c2028BD86);

    // BSC测试网PancakeSwap路由器
    address public coinAddress;
    address public lpAddress;

    // === 流动性管理相关状态变量 ===
    address public factoryAddress;              // 工厂合约地址
    bool public liquidityAdded = false;         // 防重复添加流动性标志
    uint256 public slippageProtection = 500;    // 滑点保护 5% = 500/10000
    uint256 public liquidityTokenAmount;        // 用于流动性的代币数量
    uint256 public liquidityUSDTAmount;         // 用于流动性的USDT数量
    address public lpTokenReceiver;             // LP代币接收地址
    uint256 public totalLPTokens;               // 总LP代币数量

    // === 流动性管理（简化为BNB模式） ===
    uint256 public liquidityBNBAmount;                        // 用于BNB流动性的BNB数量

    mapping(address=>bool) public managerList;
    mapping(address => preSaleStruct) public preSaleAddress;
    mapping(address => uint256) public lockAmount;
    mapping(uint256 => address) public addressIndex;
    mapping(address => uint256) public tradeCount;
    mapping(address => bool) public canTrade;

    uint256 private preSaleEthAmount; 
    uint256 private tadeEthAmount; 
    uint256 private coinAmount;
    uint256 private preSaleMaxNum;
    uint256 private maxTotalNum;
    uint256 private totalNum = 0;

    uint256 private allTradeBNB;
    uint256 private allTradeAmount;

    // === BNB累积机制相关状态变量 ===
    uint256 public accumulatedBNB = 0;          // 累积的BNB总量
    uint256 public totalPresaleBNB = 0;         // 预售阶段累积的BNB
    bool public bnbAccumulationEnabled = true;   // BNB累积开关

    // === BNB转换USDT相关状态变量 ===
    uint256 public convertedUSDT = 0;           // 已转换的USDT数量
    uint256 public conversionSlippage = 300;    // 转换滑点保护 3% = 300/10000
    bool public conversionEnabled = true;       // 转换功能开关
    uint256 public minConversionAmount = 0.1 ether; // 最小转换金额

    // === 预售完成流程相关状态变量 ===
    bool public presaleFinalized = false;      // 预售是否已完成处理
    uint256 public finalizedTokenAmount = 0;   // 最终用于流动性的代币数量
    uint256 public finalizedUSDTAmount = 0;    // 最终用于流动性的USDT数量
    bool public autoFinalizationEnabled = true; // 自动完成开关

    uint256 public presaleStatus = 0;
    uint256 public lastIndex = 0;
     
    uint256 public nowStage = 0;
    uint256 public stageUnlockRate = 10;
    uint256 public marketDisAmount = 1500000 ether;
    uint256 public lastMarketAmount = 0;

    uint256 public feeTotal = 8000;

    uint256 public maxInsideNum = 1;

    struct preSaleStruct{
        address user;
        uint256 preSaleCount;
        uint256 hasUnlockAmount;
        uint256 stage;
        bool verify;
    }

    event Minted(address indexed to, uint256 amount, uint256 ethAmount);
    event Unlock(address indexed to, uint256 ethAmount, uint256 coinAmount, uint256 time);

    // === 流动性管理相关事件 ===
    event LiquidityAdded(
        uint256 tokenAmount,
        uint256 usdtAmount,
        uint256 liquidityTokens,
        address indexed receiver
    );

    event LiquidityConfigured(
        uint256 tokenAmount,
        uint256 usdtAmount,
        uint256 slippage,
        address indexed receiver
    );

    event FactoryAddressSet(address indexed oldFactory, address indexed newFactory);
    event LiquidityFailed(string reason, uint256 tokenAmount, uint256 usdtAmount);

    // === BNB流动性相关事件 ===
    event BNBLiquidityAdded(
        uint256 tokenAmount,
        uint256 bnbAmount,
        uint256 liquidityTokens,
        address indexed receiver
    );

    // === BNB累积机制相关事件 ===
    event BNBAccumulated(address indexed user, uint256 amount, uint256 totalAccumulated);
    event BNBAccumulationToggled(bool oldEnabled, bool newEnabled);

    // === BNB转换USDT相关事件 ===
    event BNBConvertedToUSDT(uint256 bnbAmount, uint256 usdtAmount, uint256 totalUSDT);
    event ConversionConfigUpdated(uint256 slippage, uint256 minAmount, bool enabled);
    event ConversionFailed(string reason, uint256 bnbAmount);
    event EmergencyWithdraw(string tokenType, uint256 amount, address indexed to);

    // === 预售完成流程相关事件 ===
    event PresaleFinalizationStarted(uint256 bnbAmount, uint256 timestamp);
    event TokensReceivedFromFactory(uint256 tokenAmount, address indexed factory);
    event LiquidityParametersCalculated(uint256 tokenAmount, uint256 usdtAmount);
    event PresaleFinalizationCompleted(
        uint256 tokenAmount,
        uint256 usdtAmount,
        uint256 liquidityTokens,
        address indexed lpReceiver,
        uint256 timestamp
    );
    event PresaleFinalizationFailed(string reason, uint256 step);

    constructor() {
        setPoolData(0.3 ether, 0.29 ether, 500, 1, 0 ether, 10);
    }
    
    modifier onlyManager() {
        require( managerList[msg.sender] , "Ownable: caller is not the manager");
        _;
    }
    
    function setManager(address _address , bool isManager) public onlyOwner{
        managerList[_address]=isManager;
    }



    function setVerify(address _addr, bool verify) external onlyOwner payable {
        preSaleStruct memory _p = preSaleAddress[_addr];
        uint256 _pNum = _p.preSaleCount;
        require(_pNum != 0 && _p.hasUnlockAmount == 0, "Not presaled");

        _p.verify = verify;
        if(verify == false){
             _p.preSaleCount = 0;
            require(msg.value >= (_pNum * preSaleEthAmount), "Not enough");
            _transferETH(_addr, (_pNum * preSaleEthAmount));
        }
        preSaleAddress[_addr] = _p;
    }

    function setCoinAddress(address _coin) external onlyOwner {
        coinAddress = _coin;
        IPancakeFactory factory = IPancakeFactory(router.factory());
        lpAddress = factory.getPair(USDT, coinAddress);
    }

    function setFeeRate(uint256 _feeRate) external onlyOwner {
        require(_feeRate < 10000, "rate error");
        feeTotal = _feeRate;
    }

    function setCoinAmount(uint256 _coinAmount) external onlyOwner {
        coinAmount = _coinAmount;
    }

    function setPresaleStatus(uint256 _presaleStatus) external onlyOwner {
        presaleStatus = _presaleStatus;
    }

    function setMarketDisAmount(uint256 _dis) external onlyOwner {
        marketDisAmount = _dis;
    }

    function setMaxInsideNum(uint256 _maxInsideNum) external onlyOwner {
        maxInsideNum = _maxInsideNum;
    }


    /**
     * @dev 动态获取代币总供应量
     * @return 代币总供应量，如果获取失败则返回默认值
     */
    function getTotalSupply() public view returns(uint256) {
        // 检查代币地址是否已设置
        if(coinAddress == address(0)) {
            return 21000000 ether; // 默认值，用于代币地址未设置的情况
        }

        // 尝试获取代币合约的实际总供应量
        try IERC20(coinAddress).totalSupply() returns (uint256 totalSupply) {
            require(totalSupply > 0, "Invalid total supply");
            return totalSupply;
        } catch {
            // 降级方案：返回默认值
            return 21000000 ether;
        }
    }

    function setPoolData(uint256 _single,uint256 _trade, uint256 _total, uint256 _max, uint256 _coin, uint256 _rate) public onlyOwner {
        preSaleEthAmount = _single;
        tadeEthAmount = _trade;
        maxTotalNum = _total;
        preSaleMaxNum = _max;
        coinAmount = _coin;
        stageUnlockRate = _rate;
    }

    function getMarketPrice() public view returns(uint256){

        uint256 _amount = IERC20(USDT).balanceOf(CCoin(coinAddress).pairUSDT());
        uint256 _coin = IERC20(coinAddress).balanceOf(CCoin(coinAddress).pairUSDT());
        
        // 使用动态获取的总供应量
        uint256 currentSupply = getTotalSupply();
        uint256 price = (currentSupply * _amount) / _coin;
        return price;                    
    }

    function supply() public view returns(uint256) {
    return getTotalSupply();
    }
    function getInsidePrice() public view returns(uint256){
        return (allTradeAmount / allTradeBNB); 
    }

    function advanceStage() external onlyOwner{
        uint price = getMarketPrice();
        if(price - lastMarketAmount >= marketDisAmount){
            require(nowStage < 1000/stageUnlockRate, "max");
            nowStage++;
            lastMarketAmount = lastMarketAmount + marketDisAmount;
        }
    }

    function unlock() external {     
        require(presaleStatus >= 3, "In presale");
        require(coinAmount != 0,  "Not lp");
        preSaleStruct memory _p = preSaleAddress[msg.sender];
        require(_p.verify == true && msg.sender == _p.user, "Not verified");
        require(_p.preSaleCount != 0 && _p.hasUnlockAmount < coinAmount, "Not presaled");
        uint256 _dis = (nowStage - _p.stage);
        uint256 _unlockAmount = (coinAmount * _dis * stageUnlockRate) / 1000;

        IPancakePair(lpAddress).approve(address(router), _unlockAmount);
        (uint256 amount, uint256 amountUSDT) = router.removeLiquidity(
            coinAddress,
            USDT,
            _unlockAmount,
            0,
            0,
            address(this),
            block.timestamp
        );

       require(amount != 0 && amountUSDT != 0, "Error");

        TransferHelper.safeTransfer(coinAddress,address(0xdead),amount);
        TransferHelper.safeTransfer(USDT,msg.sender,amountUSDT);

        _p.stage = nowStage;
        _p.hasUnlockAmount = _p.hasUnlockAmount + _unlockAmount;
        preSaleAddress[msg.sender] = _p;

        emit Unlock(msg.sender, coinAmount, _unlockAmount, block.timestamp);
    }

    receive() external payable {

    }

    fallback() external payable { 

    }

    /**
     * @dev 统一的ETH转账函数
     * @param to 接收地址
     * @param amount 转账金额
     */
    function _transferETH(address to, uint256 amount) private {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Invalid amount");
        payable(to).transfer(amount);
    }

    /**
     * @dev 计算代币余额变化
     * @param token 代币地址
     * @param account 账户地址
     * @param beforeBalance 操作前余额
     * @return 余额变化量
     */
    function _getBalanceChange(
        address token,
        address account,
        uint256 beforeBalance
    ) private view returns (uint256) {
        uint256 afterBalance = IERC20(token).balanceOf(account);
        return afterBalance > beforeBalance ? afterBalance - beforeBalance : 0;
    }

    /**
     * @dev 统一的ETH到代币交换函数
     * @param token 目标代币地址
     * @param amount ETH数量
     * @param to 接收地址
     * @return amountOut 实际获得的代币数量
     */
    function _swapETHToToken(
        address token,
        uint256 amount,
        address to
    ) private returns (uint256 amountOut) {
        // 构建交换路径: ETH -> USDT -> Token
        address[] memory path = new address[](3);
        path[0] = router.WETH();
        path[1] = USDT;
        path[2] = token;

        // 记录交换前余额
        uint256 beforeBalance = IERC20(token).balanceOf(to);

        // 执行交换
        router.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: amount
        }(0, path, to, block.timestamp);

        // 计算实际获得的代币数量
        amountOut = _getBalanceChange(token, to, beforeBalance);
    }

    function preSale() external payable{
        preSaleStruct memory _p = preSaleAddress[msg.sender];
        uint256 _pNum = _p.preSaleCount;
        uint256 _copies = msg.value / preSaleEthAmount;

        // 预售未开始或无效支付，直接转给平台方
        if(presaleStatus == 0 || _copies == 0){
            _transferETH(owner(), msg.value);
            return;
        }

        // 预售已结束或达到上限，直接转给平台方
        if(presaleStatus >= 2 || totalNum >= maxTotalNum){
           _transferETH(owner(), msg.value);
           return;
        }

        // 有效的预售购买
        if ((_pNum+_copies) <= preSaleMaxNum && (totalNum+_copies) <= maxTotalNum ){

            // BNB累积机制：全部累积，不收取手续费
            // 全部BNB累积到合约中
                accumulatedBNB += msg.value;
                totalPresaleBNB += msg.value;

                emit BNBAccumulated(msg.sender, msg.value, accumulatedBNB);
         

            // 更新用户预售信息
            if(_p.user == address(0)){
                _p.user = msg.sender;
                _p.preSaleCount = _copies;
                _p.verify = true;
                addressIndex[lastIndex] = msg.sender;
                lastIndex++;
            }else {
                _p.preSaleCount = (_pNum + _copies);
            }
            preSaleAddress[msg.sender] = _p;
            totalNum = (totalNum + _copies);

            emit Minted(msg.sender,_pNum+_copies,msg.value);

        }else {
            // 超出限制，直接转给平台方
            _transferETH(owner(), msg.value);
        }
    }

    function trade() external payable{
        require(presaleStatus == 3 , "Cant trade");
        require(msg.value != 0, "Zero");
       
        uint256 _pNum = tradeCount[msg.sender];
        uint256 _copies = msg.value / tadeEthAmount;

        if(canTrade[msg.sender] == false){
            preSaleStruct memory _p = preSaleAddress[msg.sender];
            require(_p.preSaleCount != 0 && _p.verify == true, "No verify");
        }
        
        if(_copies == 0 || (_copies+_pNum) > maxInsideNum){
            revert("Cant trade");
        }
        
    // 直接用全部 BNB 进行一次交换
    uint256 _cAmount = _swapETHToToken(coinAddress, msg.value, address(this));
    require(_cAmount != 0, "Error, no swap");

     // 统一使用内部交易模式，代币保留在合约中
        allTradeAmount = allTradeAmount + _cAmount  ;
        allTradeBNB = (allTradeBNB + msg.value);
        tradeCount[msg.sender]=_copies+_pNum;
    } 

    function tradeUnlock() external {
        require(presaleStatus >= 4, "Not in unlock phase");
        uint256 _pNum = tradeCount[msg.sender];
        require(_pNum != 0, "Not trade inside");

        uint256 _amount = _pNum * getInsidePrice() * tadeEthAmount;
        require(_amount != 0, "Price zero");
        tradeCount[msg.sender] = 0;

        TransferHelper.safeTransfer(coinAddress,msg.sender,_amount);

    }

    function sellToken(uint256 _amount) external {
        require(_amount != 0 && presaleStatus == 5,"Error: transfer failed");
        uint256 beforeBalance = IERC20(coinAddress).balanceOf(address(this));
        TransferHelper.safeTransferFrom(coinAddress,msg.sender,address(this),_amount);

        uint256 _outAmount = _getBalanceChange(coinAddress, address(this), beforeBalance);
        require(_outAmount != 0,"Error: transfer failed");
        uint256 fee = (_outAmount * feeTotal) / 10000;

        // 获取代币合约的手续费接收地址
        address feeRecipient = StagedCustomToken(payable(coinAddress)).feeRecipient();
        require(feeRecipient != address(0), "Invalid fee recipient");
        TransferHelper.safeTransfer(coinAddress, feeRecipient, fee);
        _outAmount -= fee;

        IERC20(coinAddress).approve(address(router), _outAmount);
        address[] memory path = new address[](2);
        path[0] = coinAddress;
        path[1] = USDT;
    
        uint256 beforeUSDTBalance = IERC20(USDT).balanceOf(address(this));
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(_outAmount,1, path, address(this), block.timestamp);
        uint256 amountOut = _getBalanceChange(USDT, address(this), beforeUSDTBalance);

        if(amountOut > 0) {
            TransferHelper.safeTransfer(USDT,msg.sender,amountOut);
        }

    }
    


    // === BNB累积机制管理函数 ===

    /**
     * @dev 设置BNB累积开关
     * @param _enabled 是否启用BNB累积
     */
    function setBNBAccumulation(bool _enabled) external onlyOwner {
        bool oldEnabled = bnbAccumulationEnabled;
        bnbAccumulationEnabled = _enabled;
        emit BNBAccumulationToggled(oldEnabled, _enabled);
    }

    /**
     * @dev 查询BNB累积状态
     * @return accumulatedAmount 累积的BNB数量
     * @return presaleAmount 预售阶段累积的BNB
     * @return isEnabled 是否启用累积
     */
    function getBNBAccumulationStatus() external view returns (
        uint256 accumulatedAmount,
        uint256 presaleAmount,
        bool isEnabled
    ) {
        return (
            accumulatedBNB,
            totalPresaleBNB,
            bnbAccumulationEnabled
        );
    }

    /**
     * @dev 查询合约BNB余额
     * @return 合约当前BNB余额
     */
    function getContractBNBBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // === BNB转换USDT功能 ===

    /**
     * @dev 设置转换参数
     * @param _slippage 滑点保护 (basis points, 300 = 3%)
     * @param _minAmount 最小转换金额
     * @param _enabled 是否启用转换功能
     */
    function setConversionConfig(
        uint256 _slippage,
        uint256 _minAmount,
        bool _enabled
    ) external onlyOwner {
        require(_slippage <= 1000, "Slippage too high"); // 最大10%
        require(_minAmount > 0, "Invalid min amount");

        conversionSlippage = _slippage;
        minConversionAmount = _minAmount;
        conversionEnabled = _enabled;

        emit ConversionConfigUpdated(_slippage, _minAmount, _enabled);
    }


    /**
     * @dev 查询转换状态和配置
     */
    function getConversionStatus() external view returns (
        uint256 accumulatedBNBAmount,
        uint256 convertedUSDTAmount,
        uint256 contractUSDTBalance,
        uint256 slippage,
        uint256 minAmount,
        bool enabled
    ) {
        return (
            accumulatedBNB,
            convertedUSDT,
            IERC20(USDT).balanceOf(address(this)),
            conversionSlippage,
            minConversionAmount,
            conversionEnabled
        );
    }

    /**
     * @dev 紧急提取BNB（仅在紧急情况下使用）
     * @param amount 提取数量 (0表示全部)
     * @param to 接收地址
     */
    function emergencyWithdrawBNB(uint256 amount, address to) external onlyOwner {
        require(to != address(0), "Invalid recipient");
        require(!conversionEnabled, "Disable conversion first");

        uint256 withdrawAmount = amount == 0 ? address(this).balance : amount;
        require(withdrawAmount > 0, "No BNB to withdraw");
        require(address(this).balance >= withdrawAmount, "Insufficient balance");

        // 更新累积状态
        if (withdrawAmount <= accumulatedBNB) {
            accumulatedBNB -= withdrawAmount;
        } else {
            accumulatedBNB = 0;
        }

        _transferETH(to, withdrawAmount);
        emit EmergencyWithdraw("BNB", withdrawAmount, to);
    }

    /**
     * @dev 紧急提取USDT（仅在紧急情况下使用）
     * @param amount 提取数量 (0表示全部)
     * @param to 接收地址
     */
    function emergencyWithdrawUSDT(uint256 amount, address to) external onlyOwner {
        require(to != address(0), "Invalid recipient");

        uint256 contractBalance = IERC20(USDT).balanceOf(address(this));
        uint256 withdrawAmount = amount == 0 ? contractBalance : amount;
        require(withdrawAmount > 0, "No USDT to withdraw");
        require(contractBalance >= withdrawAmount, "Insufficient USDT balance");

        TransferHelper.safeTransfer(USDT, to, withdrawAmount);
        emit EmergencyWithdraw("USDT", withdrawAmount, to);
    }

    // === 预售完成整合流程 ===

    /**
     * @dev 验证工厂合约授权状态
     * @return hasAuthorization 是否有授权
     * @return authorizedAmount 授权数量
     * @return contractBalance 合约当前代币余额
     */
    function validateFactoryAuthorization() public view returns (
        bool hasAuthorization,
        uint256 authorizedAmount,
        uint256 contractBalance
    ) {
        if (factoryAddress == address(0) || coinAddress == address(0)) {
            return (false, 0, 0);
        }

        authorizedAmount = IERC20(coinAddress).allowance(factoryAddress, address(this));
        contractBalance = IERC20(coinAddress).balanceOf(address(this));
        hasAuthorization = authorizedAmount > 0;
    }

    /**
     * @dev 自动计算流动性参数
     * @param availableUSDT 可用的USDT数量
     * @param availableTokens 可用的代币数量
     * @return tokenAmount 用于流动性的代币数量
     * @return usdtAmount 用于流动性的USDT数量
     */
    function calculateLiquidityParams(
        uint256 availableUSDT,
        uint256 availableTokens
    ) public pure returns (uint256 tokenAmount, uint256 usdtAmount) {
        require(availableUSDT > 0, "No USDT available");
        require(availableTokens > 0, "No tokens available");

        // 使用全部可用的USDT和代币
        // 在实际应用中，可能需要根据预设的比例来计算
        tokenAmount = availableTokens;
        usdtAmount = availableUSDT;
    }

    /**
     * @dev 从工厂合约获取授权的代币
     * @return receivedAmount 实际获得的代币数量
     */
    function receiveTokensFromFactory() internal returns (uint256 receivedAmount) {
        (bool hasAuth, uint256 authorizedAmount,) = validateFactoryAuthorization();
        require(hasAuth, "No factory authorization");
        require(authorizedAmount > 0, "No tokens authorized");

        // 记录转账前余额
        uint256 beforeBalance = IERC20(coinAddress).balanceOf(address(this));

        // 从工厂合约转移代币到预售合约
        TransferHelper.safeTransferFrom(coinAddress, factoryAddress, address(this), authorizedAmount);

        // 计算实际获得的代币数量
        receivedAmount = _getBalanceChange(coinAddress, address(this), beforeBalance);
        require(receivedAmount > 0, "No tokens received");

        emit TokensReceivedFromFactory(receivedAmount, factoryAddress);
    }



    /**
     * @dev 获取USDT/TOKEN池子的USDT流动性
     * @return USDT流动性数量
     */
    function _getUSDTPoolLiquidity() internal view returns (uint256) {
        if (coinAddress == address(0)) {
            return 0;
        }

        try IPancakeFactory(router.factory()).getPair(USDT, coinAddress) returns (address pairAddress) {
            if (pairAddress == address(0)) {
                return 0; // 池子不存在
            }

            // 获取池子中的USDT余额
            return IERC20(USDT).balanceOf(pairAddress);
        } catch {
            return 0; // 查询失败，返回0
        }
    }

    /**
     * @dev 检查BNB/TOKEN池子是否存在
     * @return 池子是否存在
     */
    function _checkBNBPoolExists() internal view returns (bool) {
        if (coinAddress == address(0)) {
            return false;
        }

        try IPancakeFactory(router.factory()).getPair(router.WETH(), coinAddress) returns (address pairAddress) {
            return pairAddress != address(0);
        } catch {
            return false;
        }
    }

    // 智能选择系统已移除，简化为BNB模式

    // 智能选择配置函数已移除

    // 手动设置流动性类型函数已移除

    /**
     * @dev 查询当前流动性选择状态
     * @return currentType 当前流动性类型
     * @return autoEnabled 是否启用自动选择
     * @return threshold 最小USDT阈值
     * @return usdtLiquidity 当前USDT池子流动性
     * @return bnbPoolExists BNB池子是否存在
     */
    function getLiquiditySelectionStatus() external view returns (
        LiquidityType currentType,
        bool autoEnabled,
        uint256 threshold,
        uint256 usdtLiquidity,
        bool bnbPoolExists
    ) {
        return (
            liquidityType,
            autoLiquiditySelection,
            minUSDTLiquidityThreshold,
            _getUSDTPoolLiquidity(),
            _checkBNBPoolExists()
        );
    }

    /**
     * @dev 预售完成后的统一处理函数
     * 整合BNB转换、代币获取、流动性添加的完整流程
     */
    function finalizePresaleAndAddLiquidity() external onlyOwner nonReentrant {
        require(!presaleFinalized, "Presale already finalized");
        require(presaleStatus >= 2, "Presale not ended yet");
        require(autoFinalizationEnabled, "Auto finalization disabled");
        require(accumulatedBNB > 0, "No BNB to process");
        require(factoryAddress != address(0), "Factory address not set");
        require(coinAddress != address(0), "Token address not set");
        require(lpTokenReceiver != address(0), "LP receiver not set");

        emit PresaleFinalizationStarted(accumulatedBNB, block.timestamp);

        // 智能选择流动性类型
        _selectOptimalLiquidityType();

        try this._executeFinalizationSteps() {
            presaleFinalized = true;
            presaleStatus = 5; // 设置为完成状态

            emit PresaleFinalizationCompleted(
                finalizedTokenAmount,
                finalizedUSDTAmount,
                totalLPTokens,
                lpTokenReceiver,
                block.timestamp
            );

        } catch Error(string memory reason) {
            emit PresaleFinalizationFailed(reason, 0);
            revert(string(abi.encodePacked("Finalization failed: ", reason)));

        } catch (bytes memory /*lowLevelData*/) {
            emit PresaleFinalizationFailed("Low level error", 0);
            revert("Finalization failed with low level error");
        }
    }

    /**
     * @dev 计算BNB流动性参数
     * @param bnbAmount 可用的BNB数量
     * @param tokenAmount 可用的代币数量
     * @return tokenForLP 用于流动性的代币数量
     * @return bnbForLP 用于流动性的BNB数量
     */
    function calculateBNBLiquidityParams(uint256 bnbAmount, uint256 tokenAmount)
        internal
        pure
        returns (uint256 tokenForLP, uint256 bnbForLP)
    {
        // 使用80%的BNB用于流动性，20%保留给团队
        bnbForLP = bnbAmount * 80 / 100;

        // 使用80%的代币用于流动性
        tokenForLP = tokenAmount * 80 / 100;

        return (tokenForLP, bnbForLP);
    }

    /**
     * @dev 执行完成流程的具体步骤（内部函数，支持try-catch）
     */
    function _executeFinalizationSteps() external {
        require(msg.sender == address(this), "Internal function only");

        // 步骤1: 从工厂获取代币
        uint256 tokensReceived = receiveTokensFromFactory();
        require(tokensReceived > 0, "Token reception failed");

        // 步骤2: 根据流动性类型执行不同逻辑
        if (liquidityType == LiquidityType.USDT) {
            // USDT流动性模式：转换BNB为USDT
            uint256 usdtReceived = this.convertBNBToUSDT(0); // 转换全部BNB
            require(usdtReceived > 0, "BNB conversion failed");

            // 计算USDT流动性参数
            (uint256 tokenAmount, uint256 usdtAmount) = calculateLiquidityParams(usdtReceived, tokensReceived);
            emit LiquidityParametersCalculated(tokenAmount, usdtAmount);

            // 配置USDT流动性参数
            liquidityTokenAmount = tokenAmount;
            liquidityUSDTAmount = usdtAmount;
            finalizedTokenAmount = tokenAmount;
            finalizedUSDTAmount = usdtAmount;

            // 添加USDT流动性
            _addLiquidityInternal();

        } else {
            // BNB流动性模式：直接使用BNB
            uint256 bnbAmount = accumulatedBNB;

            // 计算BNB流动性参数
            (uint256 tokenAmount, uint256 bnbAmountForLP) = calculateBNBLiquidityParams(bnbAmount, tokensReceived);

            // 配置BNB流动性参数
            liquidityTokenAmount = tokenAmount;
            liquidityBNBAmount = bnbAmountForLP;
            finalizedTokenAmount = tokenAmount;
            finalizedUSDTAmount = 0; // BNB模式下USDT为0

            // 添加BNB流动性
            _addBNBLiquidityInternal();
        }
    }

    /**
     * @dev 内部BNB流动性添加函数
     */
    function _addBNBLiquidityInternal() internal {
        require(!liquidityAdded, "Liquidity already added");
        require(liquidityTokenAmount > 0, "Token amount not configured");
        require(liquidityBNBAmount > 0, "BNB amount not configured");

        uint256 tokenAmount = liquidityTokenAmount;
        uint256 bnbAmount = liquidityBNBAmount;

        // 计算滑点保护参数
        uint256 tokenAmountMin = tokenAmount * (10000 - slippageProtection) / 10000;
        uint256 bnbAmountMin = bnbAmount * (10000 - slippageProtection) / 10000;

        // 授权路由器使用代币（精确授权）
        _safeApprove(coinAddress, address(router), tokenAmount);

        // 添加BNB流动性（带错误处理）
        try router.addLiquidityETH{value: bnbAmount}(
            coinAddress,                    // token
            tokenAmount,                   // amountTokenDesired
            tokenAmountMin,                // amountTokenMin (滑点保护)
            bnbAmountMin,                  // amountETHMin (滑点保护)
            lpTokenReceiver,               // to (LP代币接收者)
            block.timestamp + 300          // deadline (5分钟)
        ) returns (uint amountToken, uint amountETH, uint liquidity) {

            // 更新状态
            liquidityAdded = true;
            totalLPTokens = liquidity;

            // 更新累积BNB（减去用于流动性的部分）
            accumulatedBNB -= bnbAmount;

            // 发射成功事件
            emit BNBLiquidityAdded(amountToken, amountETH, liquidity, lpTokenReceiver);

            // 尝试自动放弃Token权限
            _tryRenounceTokenOwnership();

        } catch Error(string memory reason) {
            _handleLiquidityFailure(reason);
        } catch (bytes memory) {
            _handleLiquidityFailure("BNB liquidity addition failed with low level error");
        }
    }

    /**
     * @dev 内部流动性添加函数（复用现有addLiquidity的核心逻辑）
     */
    function _addLiquidityInternal() internal {
        require(!liquidityAdded, "Liquidity already added");
        require(liquidityTokenAmount > 0, "Token amount not configured");
        require(liquidityUSDTAmount > 0, "USDT amount not configured");

        uint256 tokenAmount = liquidityTokenAmount;
        uint256 usdtAmount = liquidityUSDTAmount;

        // 计算滑点保护参数
        uint256 tokenAmountMin = tokenAmount * (10000 - slippageProtection) / 10000;
        uint256 usdtAmountMin = usdtAmount * (10000 - slippageProtection) / 10000;

        // 授权路由器使用代币（精确授权）
        _safeApprove(coinAddress, address(router), tokenAmount);
        _safeApprove(USDT, address(router), usdtAmount);

        // 添加流动性（带错误处理）
        try router.addLiquidity(
            coinAddress,                    // tokenA
            USDT,                          // tokenB
            tokenAmount,                   // amountADesired
            usdtAmount,                    // amountBDesired
            tokenAmountMin,                // amountAMin (滑点保护)
            usdtAmountMin,                 // amountBMin (滑点保护)
            lpTokenReceiver,               // to (LP代币接收者)
            block.timestamp + 300          // deadline (5分钟)
        ) returns (uint amountA, uint amountB, uint liquidity) {

            // 成功处理
            liquidityAdded = true;
            totalLPTokens = liquidity;

            // 撤销剩余授权
            _safeApprove(coinAddress, address(router), 0);
            _safeApprove(USDT, address(router), 0);

            // 发射成功事件
            emit LiquidityAdded(amountA, amountB, liquidity, lpTokenReceiver);

            // 尝试自动放弃Token权限
            _tryRenounceTokenOwnership();

        } catch Error(string memory reason) {
            // 处理已知错误
            _handleLiquidityFailure(reason);
            revert(string(abi.encodePacked("Liquidity failed: ", reason)));

        } catch (bytes memory /*lowLevelData*/) {
            // 处理低级错误
            _handleLiquidityFailure("Low level error");
            revert("Liquidity addition failed with low level error");
        }
    }

    /**
     * @dev 设置自动完成开关
     * @param _enabled 是否启用自动完成
     */
    function setAutoFinalization(bool _enabled) external onlyOwner {
        autoFinalizationEnabled = _enabled;
    }


    /**
     * @dev 查询预售完成状态
     */
    function getFinalizationStatus() external view returns (
        bool isFinalized,
        bool autoEnabled,
        uint256 tokenAmount,
        uint256 usdtAmount,
        bool liquidityAdded_,
        uint256 lpTokens
    ) {
        return (
            presaleFinalized,
            autoFinalizationEnabled,
            finalizedTokenAmount,
            finalizedUSDTAmount,
            liquidityAdded,
            totalLPTokens
        );
    }

    // === 流动性管理功能 ===

    /**
     * @dev 设置工厂合约地址
     * @param _factoryAddress 工厂合约地址
     */
    function setFactoryAddress(address _factoryAddress) external onlyOwner {
        require(_factoryAddress != address(0), "Invalid factory address");
        address oldFactory = factoryAddress;
        factoryAddress = _factoryAddress;
        emit FactoryAddressSet(oldFactory, _factoryAddress);
    }

    /**
     * @dev 配置流动性参数
     * @param _tokenAmount 代币数量
     * @param _usdtAmount USDT数量
     * @param _slippage 滑点保护 (basis points, 500 = 5%)
     * @param _lpReceiver LP代币接收地址
     */
    function configureLiquidity(
        uint256 _tokenAmount,
        uint256 _usdtAmount,
        uint256 _slippage,
        address _lpReceiver
    ) external onlyOwner {
        require(_tokenAmount > 0, "Invalid token amount");
        require(_usdtAmount > 0, "Invalid USDT amount");
        require(_slippage <= 1000, "Slippage too high"); // 最大10%
        require(_lpReceiver != address(0), "Invalid LP receiver");

        liquidityTokenAmount = _tokenAmount;
        liquidityUSDTAmount = _usdtAmount;
        slippageProtection = _slippage;
        lpTokenReceiver = _lpReceiver;

        emit LiquidityConfigured(_tokenAmount, _usdtAmount, _slippage, _lpReceiver);
    }

    /**
     * @dev 安全授权函数 - 先撤销再授权
     * @param token 代币地址
     * @param spender 被授权地址
     * @param amount 授权数量
     */
    function _safeApprove(address token, address spender, uint256 amount) internal {
        // 先撤销现有授权
        TransferHelper.safeApprove(token, spender, 0);
        // 再设置新的授权
        if (amount > 0) {
            TransferHelper.safeApprove(token, spender, amount);
        }
    }

    /**
     * @dev 确保合约有足够的代币余额
     * @param tokenAmount 需要的代币数量
     * @param usdtAmount 需要的USDT数量
     */
  function _ensureTokenBalance(uint256 tokenAmount, uint256 usdtAmount) internal {
        // 检查并获取项目代币
        uint256 currentTokenBalance = IERC20(coinAddress).balanceOf(address(this));
        if (currentTokenBalance < tokenAmount) {
            uint256 needed = tokenAmount - currentTokenBalance;
            // 从工厂合约获取代币
            TransferHelper.safeTransferFrom(coinAddress, factoryAddress, address(this), needed);
        }

        // 检查USDT余额
        uint256 currentUSDTBalance = IERC20(USDT).balanceOf(address(this));
        require(currentUSDTBalance >= usdtAmount, "Insufficient USDT balance");
    }

    /**
     * @dev 处理流动性添加失败的情况
     * @param reason 失败原因
     */
    function _handleLiquidityFailure(string memory reason) internal {
        // 撤销所有授权
        _safeApprove(coinAddress, address(router), 0);
        _safeApprove(USDT, address(router), 0);

        // 发射失败事件
        emit LiquidityFailed(reason, liquidityTokenAmount, liquidityUSDTAmount);
    }

    /**
     * @dev 核心流动性添加函数
     * 使用PancakeSwap路由器添加代币/USDT流动性
     */
    function addLiquidity() external onlyOwner nonReentrant {
        require(!liquidityAdded, "Liquidity already added");
        require(coinAddress != address(0), "Token not set");
        require(factoryAddress != address(0), "Factory address not set");
        require(liquidityTokenAmount > 0, "Token amount not configured");
        require(liquidityUSDTAmount > 0, "USDT amount not configured");
        require(lpTokenReceiver != address(0), "LP receiver not set");

        uint256 tokenAmount = liquidityTokenAmount;
        uint256 usdtAmount = liquidityUSDTAmount;

        // 1. 确保合约有足够的代币余额
        _ensureTokenBalance(tokenAmount, usdtAmount);

        // 2. 计算滑点保护参数
        uint256 tokenAmountMin = tokenAmount * (10000 - slippageProtection) / 10000;
        uint256 usdtAmountMin = usdtAmount * (10000 - slippageProtection) / 10000;

        // 3. 授权路由器使用代币（精确授权）
        _safeApprove(coinAddress, address(router), tokenAmount);
        _safeApprove(USDT, address(router), usdtAmount);

        // 4. 添加流动性（带错误处理）
        try router.addLiquidity(
            coinAddress,                    // tokenA
            USDT,                          // tokenB
            tokenAmount,                   // amountADesired
            usdtAmount,                    // amountBDesired
            tokenAmountMin,                // amountAMin (滑点保护)
            usdtAmountMin,                 // amountBMin (滑点保护)
            lpTokenReceiver,               // to (LP代币接收者)
            block.timestamp + 300          // deadline (5分钟)
        ) returns (uint amountA, uint amountB, uint liquidity) {

            // 5. 成功处理
            liquidityAdded = true;
            totalLPTokens = liquidity;

            // 6. 撤销剩余授权
            _safeApprove(coinAddress, address(router), 0);
            _safeApprove(USDT, address(router), 0);

            // 7. 发射成功事件
            emit LiquidityAdded(amountA, amountB, liquidity, lpTokenReceiver);

        } catch Error(string memory reason) {
            // 处理已知错误
            _handleLiquidityFailure(reason);
            revert(string(abi.encodePacked("Liquidity failed: ", reason)));

        } catch (bytes memory /* lowLevelData */) {
            // 处理低级错误
            _handleLiquidityFailure("Low level error");
            revert("Liquidity addition failed with low level error");
        }
    }


    /**
     * @dev 查询工厂合约对预售合约的代币授权额度
     * @return 剩余授权额度
     */
    function getFactoryAllowance() external view returns (uint256) {
        if (factoryAddress == address(0) || coinAddress == address(0)) {
            return 0;
        }
        return IERC20(coinAddress).allowance(factoryAddress, address(this));
    }

    /**
     * @dev 查询合约当前的代币余额
     * @return tokenBalance 项目代币余额
     * @return usdtBalance USDT余额
     */
    function getContractBalances() external view returns (uint256 tokenBalance, uint256 usdtBalance) {
        tokenBalance = coinAddress != address(0) ? IERC20(coinAddress).balanceOf(address(this)) : 0;
        usdtBalance = IERC20(USDT).balanceOf(address(this));
    }

    /**
     * @dev 查询流动性配置信息
     */
    function getLiquidityConfig() external view returns (
        uint256 tokenAmount,
        uint256 usdtAmount,
        uint256 slippage,
        address lpReceiver,
        bool added,
        uint256 lpTokens
    ) {
        return (
            liquidityTokenAmount,
            liquidityUSDTAmount,
            slippageProtection,
            lpTokenReceiver,
            liquidityAdded,
            totalLPTokens
        );
    }

    /**
     * @dev 尝试自动放弃Token权限（内部函数）
     * 在流动性添加成功后调用
     */
    function _tryRenounceTokenOwnership() internal {
        if (coinAddress == address(0)) return;

        // 先设置预售合约地址
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = coinAddress.call(
            abi.encodeWithSignature("setPresaleContract(address)", address(this))
        );
        success; // 静默忽略返回值

        // 然后调用权限放弃函数
        // solhint-disable-next-line avoid-low-level-calls
        (success, ) = coinAddress.call(
            abi.encodeWithSignature("renounceOwnershipByPresale()")
        );
        success; // 静默忽略返回值

        // 静默处理，不影响主流程
    }

}


